
# 方法论

## 单调栈

维护 `nums[i]` 前面 `<=nums[i]` 或者 `>=nums[i]` 最近的元素位置。

# 题目

## LC 42. 接雨水（重点）

描述：
```LaTeX
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
```

思考：

方法一：双指针。方法二：单调栈。

代码：
```Java
class Solution {
    public int trap01(int[] height) {
        int n = height.length;
        int i = 0, j = n - 1;
        int left = height[0], right = height[n - 1];
        int ans = 0;
        while (i < j) {
            // 先更新再加
            // 条件具有二分性
            if (left < right) {
                i++;
                left = Math.max(left, height[i]);
                ans += left - height[i];
            } else {
                j--;
                right= Math.max(right, height[j]);
                ans += right - height[j];
            }
        }
        return ans;
    }

    public int trap(int[] height) {
        int n = height.length;
        int ans = 0;
        Deque<int[]> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int rightHeight = height[i];
            // 栈中不能相等，栈中的元素比栈顶的元素比大，右边的元素也比栈顶的元素大
            while (!stack.isEmpty() && stack.peek()[0] <= rightHeight) {
                int h = stack.pop()[0];
                // 接雨水是两个元素之间的间隔
                if (!stack.isEmpty()) {
                    int leftHeight = stack.peek()[0];
                    int leftBorder = stack.peek()[1];
                    int w = i - leftBorder - 1;
                    ans += w * (Math.min(leftHeight, rightHeight) - h);
                }
            }
            stack.push(new int[]{rightHeight, i});
        }
        return ans;
    }
}
```

## LC 84. 柱状图中最大的矩形（重点）

描述:
```LaTeX
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

输入：heights = [2,1,5,6,2,3]
输出：10
```

思考：
```LaTeX
下标 i 枚举的是右边界，单调栈 stack 自底向顶非严格递增。if (stack.peek()[0] > heights[i])，栈顶高度的右边界就找到了，左边界被 stack 维护了。

注意点：哨兵机制。heights = [2,1,5,6,2,3]，遍历 heights 一开始要插入 0 代表 heights[0] 的左边界；最后也要加入 0，代表 heights[n - 1] 的右边界。

遍历过程：
stack = 0
stack = 0,2
stack = 0,1,5,6
stack = 0,1,2,3,0
stack = 0,0（非严格递增）
```

代码：
```Java
class Solution {
    public int largestRectangleArea(int[] heights) {
        // 单调栈
        int n = heights.length;
        Deque<int[]> stack = new ArrayDeque<>();
        stack.push(new int[]{0, -1});
        int ans = 0;
        for (int i = 0; i <= n; i++) {
            int h;
            if (i == n) {
                h = 0;
            } else {
                h = heights[i];
            }
            // 非严格的单调栈
            // 找到 nums[i] 前面 <= nums[i] 最近的元素位置
            while (!stack.isEmpty() && stack.peek()[0] > h) {
                int[] pop = stack.pop();
                int curHeight = pop[0];
                int leftBorder = stack.peek()[1];
                int w = i - leftBorder - 1;
                ans = Math.max(ans, w * curHeight);
            }
            stack.push(new int[]{h, i});
        }
        return ans;
    }
}
```

## LC 85. 最大矩形（重点）

描述：
```LaTeX
给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例1：
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出：6
```

思考：
```LaTeX
1 0 1 0 0
2 0 2 1 1
3 1 3 2 2
4 0 0 3 0

以 i 为结尾的连续 1 的个数，然后方法还是 LC 84. 柱状图中最大的矩形
```

代码：
```Java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        // 连续 1 的个数
        int m = matrix.length, n = matrix[0].length;
        int[] heights = new int[n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    heights[j] = 0;
                } else {
                    heights[j] += 1;
                }
            }
            // 最大矩形的面积逻辑
            ans = Math.max(ans, maxArea(heights));
        }
        return ans;
    }

    private int maxArea(int[] heights) {
        int ans = 0;
        Deque<int[]> stack = new ArrayDeque<>();
        stack.push(new int[]{0, -1});
        int n = heights.length;
        for (int i = 0; i <= n; i++) {
            int cur;
            if (i == n) {
                cur = 0;
            } else {
                cur = heights[i];
            }
            while (!stack.isEmpty() && stack.peek()[0] > cur) {
                int h = stack.pop()[0];
                int leftBorder = stack.peek()[1];
                int w = i - leftBorder - 1;
                ans = Math.max(ans, w * h);
            }
            stack.push(new int[]{cur, i});
        }
        return ans;
    }
}
```
