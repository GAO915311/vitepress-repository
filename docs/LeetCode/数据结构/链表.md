
# 题目

## LC 25. K 个一组反转链表

描述：
```LaTeX
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```

思考：
```LaTeX
0(dummy) -> 1 -> 2 -> 3 -> 4 -> 5

pre -> dummy
end -> dummy

0(dummy) -> 1 -> 2 -> 3 -> 4 -> 5
|	  		|	      |    |
pre			start	  end  next

0(dummy)    1 <- 2 <- 3    4 -> 5
|	  		|	      |    |
pre			start	  end  next

pre.next = end;
start.next = next;

注意：一次循环中 end 不能为空，next 可以为空。
```

一次遍历的代码：
```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 一次遍历
        ListNode dummy = new ListNode(0, head);
        ListNode pre = dummy;
        ListNode end = dummy;
        // 没有到链表的结尾
        while (end != null) {
            for (int i = 0; i < k && end != null; i++) {
                end = end.next;
            }
            if (end == null) break;
            ListNode start = pre.next;
            ListNode next = end.next;
            // 断开链表，才能反转链表
            end.next = null; // end 是结尾的节点
            pre.next = reverse(start);
            start.next = next;
            pre = start;
            end = pre;
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

两次遍历的代码：
```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 统计链表长度
        int n = 0;
        for (ListNode cur = head; cur != null; cur = cur.next) {
            ++n;
        }
        ListNode dummy = new ListNode(0, head);
        ListNode p0 = dummy, pre = dummy, cur = head;
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) {
                ListNode anchor = cur.next;
                cur.next = pre;
                pre = cur;
                cur = anchor;
            }
            // p0 头节点指向 pre
            ListNode nxt = p0.next;
            p0.next.next = cur;
            p0.next = pre;
            p0 = nxt;
            pre = p0;
        }
        return dummy.next;
    }
}
```

## LC 146. LRU 缓存

思考：
每次访问一本书（get 或者 put）的时候，把这本书抽出来（让该节点变成垃圾对象），放到书堆的顶部。

代码：
```Java
public class LRUCache {
    static class Node {
        public int key, value;
        public Node prev, next;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private int capacity;
    private Node dummy;
    private Map<Integer, Node> map;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        dummy = new Node(0, 0);
        dummy.prev = dummy;
        dummy.next = dummy;
    }

    public int get(int key) {
        Node node = getNode(key);
        return node == null ? -1 : node.value;
    }

    public void put(int key, int value) {
        Node node = getNode(key);
        if (node != null) {
            node.value = value;
            return;
        }
        node = new Node(key, value);
        // 加入节点需要操作 map
        pushFront(node);
        map.put(key, node);
        if (map.size() > capacity) {
	        // 删除节点也要操作 map
            map.remove(dummy.prev.key);
            remove(dummy.prev);
        }
    }

    /**
     * 访问 node 节点，将 node 节点（书）抽出来，放到书顶
     * @param key
     * @return
     */
    private Node getNode(int key) {
        if (!map.containsKey(key)) {
            return null;
        }
        Node node = map.get(key);
        remove(node);
        pushFront(node);
        return node;
    }

    private void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
    }

    private void pushFront(Node x) {
        x.prev = dummy;
        x.next = dummy.next;
        x.prev.next = x;
        x.next.prev = x;
    }
}
```