
迭代的算法 节点为 null 不能入栈/队列，null 是标记法的标记

# 二叉搜索树 (Binary Search Tree, BST)

中序遍历是一个有序数组

![[../../figures/LeetCode/BST01.svg|300]]

中序遍历的 pre 和 cur 指针变化,，其中 **pre 指针只有初始化时为 null，其余情况都不为 null**
1. pre = null; cur = 8;
2. pre = null; cur = 4;
3. pre = null; cur = 1;
4. pre = null; cur = null; cur = 1;
5. pre = 1; cur = null (1.right)
6. cur = 4; pre = 1
7. …


二叉树中序遍历：
```java
private static boolean inTraversal(TreeNode root) {
        if (root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        TreeNode pre = null;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) { // 不为空不能直接处理，先入栈，在指向左子树
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop(); // 能被弹出说明该节点的左子树已经访问完毕了
                System.out.print(cur.val + " ");
                if (pre != null && pre.val >= cur.val) {
                    return false;
                }
                pre = cur;
                cur = cur.right;
            }
        }
        return true;
    }
```



递归写法：
```java
private static TreeNode pre = null;

private static boolean isBST(TreeNode root) {
    // 中序遍历
    if (root == null) return true;
    boolean left = isBST(root.left);
    // 本节点的逻辑
    if (pre != null && pre.val > root.val) {
        return false;
    }
    pre = root;
    boolean right = isBST(root.right);
    return left && right;
}
```

