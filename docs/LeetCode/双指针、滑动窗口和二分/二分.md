# 方法论

在二分算法中条件对于待查找的变量具有==两段性==。

二分的本质是**两段性**，并非单调性，==一段满足某个性质，另一段不满足某个性质就可以用二分==。

未记录 363 

# 题目

## LC 29. 两数相除（重点）

描述：
```LaTeX
要求不使用乘法、除法和取余运算实现除法
```

思考：

边界条件： $2^{31}-1$ 和 $-2^{31}$ ，$-2^{31} / -1$ 会越界。

处理方法：转成**负数计算**，eg. $-2^{31}/2$，负数的范围更大。

位运算实现倍增乘法。

思路：
```LaTeX
-100 / 2 ^ n * (-3)

c = 2 ^ n，c 就是 2 的乘方
temp = 2 ^ n * (-3)

-100 - 2 ^ 5 * (-3) = -4
```

代码：

```Java
while (dividend <= divisor) {
	int temp = divisor;
	int c = 1;
	// 不能用乘法，同时也是为了防止越界 dividend <= 2 * temp
	while (dividend - temp <= temp) {
		temp <<= 1; // temp * 2
		c <<= 1; // c * 2
	}
	dividend -= temp;
	ans += c;
}
```

代码：

```Java
class Solution {
    int MAX = Integer.MAX_VALUE;
    int MIN = Integer.MIN_VALUE;

    public int divide(int dividend, int divisor) {
	    // 商越界的情况
        if (dividend == MIN && divisor == -1) {
            return MAX;
        }
        // 转成负数处理
        int sign = -1;
        if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {
            sign = 1;
        }
        dividend = -Math.abs(dividend);
        divisor = -Math.abs(divisor);
        int ans = 0;
        while (dividend <= divisor) {
	        // temp 记录的是本次循环的 divisor * 2 ^ (n)
            int temp = divisor;
            int c = 1;
            // 相等也要进入循环
            while (dividend - temp <= temp) {
                temp <<= 1; // temp * 2
                c <<= 1; // c * 2
            }
            dividend -= temp;
            ans += c;
        }
        return sign == 1 ? ans : -ans;
    }
}
```

## LC 33. 搜索旋转排序数组

描述：

```latex
整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了旋转，
使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。
例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
```

思考：

二分的本质是**两段性**，并非单调性，==一段满足某个性质，另一段不满足某个性质就可以用二分==。
本题中前半段满足 `>=nums[0]`，后半段不满足 `>=nums[0]`。先查找分割点，再向左或向右二分查找 `target` 即可。

代码：

```Java
public int search(int[] nums, int target) {
	int n = nums.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] >= nums[0]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	if (target >= nums[0]) {
		left = 0;
	} else {
		right = n - 1;
	}
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (target >= nums[mid]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	if (right < 0 || nums[right] != target) {
		return -1;
	}
	return right;
}
```

## LC 74. 搜索二维矩阵

描述：

```latex
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。
```

思考：

矩阵排列规则特殊，根据 `mid` 下标位置可以得到矩阵中的值

```latex
0 1 2 3 
4 5 6 7
8 9 10 11
```

代码为：`int x = matrix[mid / n][mid % n]`

代码：

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length, n = matrix[0].length;
    int low = 0, high = m * n - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        // 注意 n % n 的逻辑
        int x = matrix[mid / n][mid % n];
        if (x < target) {
            low = mid + 1;
        } else if (x > target) {
            high = mid - 1;
        } else {
            return true;
        }
    }
    return false;
}

public boolean searchMatrix01(int[][] matrix, int target) {
    int m = matrix.length;
    int n = matrix[0].length;
    int left = 0, right = m - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (target >= matrix[mid][0]) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    if (right < 0) {
        return false;
    }
    int[] nums = matrix[right];
    left = 0;
    right = n - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (target >= nums[mid]) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    if (right < 0 || nums[right] != target) {
        return false;
    }
    return true;
}
```

## LC 81. 搜索旋转排序数组 II

描述：

```LaTeX
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你旋转后的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
你必须尽可能减少整个操作步骤。
```

思考：

本题中数组元素不唯一，前半段数组 `>=nums[0]`，后半段数组 `<=nums[0]`，这样的条件是没有二段性的。

将结尾与 `nums[0]` 相同的元素去掉就可以恢复二段性了。后续的过程与 LC 33 相同。

```Java
public boolean search(int[] nums, int target) {
	// 本题要恢复二段性
	int n = nums.length;
	int j = n - 1;

	// 这里要保证 left <= right, 就算全部相等也要保证至少有一个值可以参与循环
	while (j > 0 && nums[j] == nums[0]) {
		j--;
	}
	int left = 0, right = j;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] >= nums[0]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	if (target >= nums[0]) {
		left = 0;
	} else {
		right = n - 1;
	}
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (target >= nums[mid]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	// 确保数值不越界
	if (right < 0 || nums[right] != target) {
		return false;
	}
	return true;
}
```

## LC 153. 寻找旋转排序数组中的最小值

描述：

```LaTeX
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
```

思考：

直接利用二段性来搜索分割点，然后再求最小值。

代码：

```Java
public int findMin(int[] nums) {
	int n = nums.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] >= nums[0]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	return left >= n ? nums[0] : Math.min(nums[0], nums[left]);
}
```

## LC 154. 寻找旋转数组中的最小值

描述：

```latex
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。
```

思考：分割点前半段 `>=nums[0]`，后半段 `<=nums[0]` 不具有二段性，还是先去重，然后再二分求分割点和最小值。

代码：

```Java
public int findMin(int[] nums) {
	int n = nums.length;
	int j = n - 1;
	while (j > 0 && nums[j] == nums[0]) {
		j--;
	}
	int left = 0, right = j;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] >= nums[0]) {
			left = mid + 1; 
		} else {
			right = mid - 1;
		}
	}
	return left > j ? nums[0] : Math.min(nums[0], nums[left]);
}
```

## LC 162. 寻找峰值（&）

描述：

```latex
峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
```

思考：

如果只有一个峰值，则数组前半段满足 `nums[i] < peak`，后半段满足 `nums[i] > peak`。

但是有多个峰值，如何思考？

当前分割点 `mid` 满足 `nums[mid] > nums[mid + 1]`，`nums[mid]` 可能为峰值，`nums[mid + 1]` 一定不是峰值，
`right = mid - 1`。

这里的二段性指的是：如果以 `mid` 为分割点，根据条件 `nums[mid] > (<) nums[mid + 1]` 的大小关系，其中的一段**一定有解**，另外一段不满足**一定有解**（可能有解，可能无解）。

**由此可见，二段性可以继续细分，01 特性（满足/不满足），还有 1? 特性（一定满足，不一定满足）**。

代码：

```Java
public int findPeakElement(int[] nums) {
	int n = nums.length;
	int left = 0, right = n - 2;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] < nums[mid + 1]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	return left;
}

public int findPeakElement01(int[] nums) {
	int n = nums.length;
	if (n == 1) return 0;
	int left = 0, right = n - 1;
	while (left < right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] < nums[mid + 1]) {
			left = mid + 1;
		} else {
			right = mid;
		}
	}
	return left;
}
```

## LC 240. 搜索二维矩阵 II

描述：

```latex
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
```

思考：

这里的矩阵行与行，列与列之间没有递增的关系。

代码：

```Java
public boolean searchMatrix(int[][] matrix, int target) {
	int m = matrix.length;
	int n = matrix[0].length;
	for (int i = 0; i < m; i++) {
		int left = 0, right = n - 1;
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (target > matrix[i][mid]) {
				left = mid + 1;
			} else if (target < matrix[i][mid]) {
				right = mid - 1;
			} else {
				return true;
			}
		}
	}
	return false;
}
```

## LC 274. H 指数

描述：

```latex
给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。

根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。
```

思考：

首先考虑 H 指数不一定在数组中，e.g. `[3,5,6,8,5]`，答案是 4。


假设 H 指数为 $x$，$f(x)$ 代表数组中大于等于 $x$ 的数有多少个，$f(x)$ 是（非严格）单调递减的。对于 $x \leq ans$ 而言，$f(x) \geq x$ 。

```latex
排序后：
     3 5 5 6 8
f(x) 5 5 5 5 4 2 1 0 ...
x    0 1 2 3 4 5 6 7 ...
```

## LC 275. H 指数 II

描述，本题中论文数组已经排序了

思考：

$f(x)$ 是可以二分查找计算的。

论文的数目可以看作下标，取中点 $mid$，则有 $n-mid$ 篇论文被引用了至少 $citations[mid]$ 次，如果 $citations[mid] \geq n-mid$，移动右边界 $right$，否则移动左边界 $left$。

```latex
citations = [0 1 3 5 6 7 8]

0 1 3 5 6 7 8
    5 4
```

代码：

```Java
public int hIndex(int[] citations) {
	int n = citations.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (citations[mid] >= n - mid) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	return n - left;
}
```

## LC 352. 将数据流变为多个不相交区间

描述：

```latex
输入：[[],[1],[],[3]]
输出：[null, null, [[1,1]], null [[1,1],[3,3]]]
```

思考：

加入数据的时候要得到上区间和下区间，为了能够得到这两个区间，需要区间数组需要 `TreeSet<int[]>` 来维护。

根据 $x$ 的值有以下 3 种情况：

- $x$ 落到了区间里面，没有操作。
- $x=y+1$ 或者 $x=w-1$，可能是两个区间，也可能两个区间连起来了
- 其余的情况就是 $x$ 单独一个区间。

```latex
 [x, y]  [w, z]
| |     |(3)    |
```

代码：

```Java
class SummaryRanges {
    private TreeSet<int[]> ts = new TreeSet<>((o1, o2) -> {
        return Integer.compare(o1[0], o2[0]);
    });
    int[] head = new int[]{-10, -10};
    int[] tail = new int[]{10010, 10010};

    public SummaryRanges() {
        ts.add(head);
        ts.add(tail);
    }
    
    public void addNum(int value) {
        int[] cur = new int[]{value, value};
        int[] prev = ts.floor(cur);
        int[] next = ts.ceiling(cur);
        // 一共 5 种情况
        if ((value >= prev[0] && value <= prev[1]) || (value >= next[0] && value <= next[1])) {
            
        } else if (value == prev[1] + 1 && value == next[0] - 1) {
            prev[1] = next[1];
            ts.remove(next);
        } else if (value == prev[1] + 1) {
            prev[1] = value;
        } else if (value == next[0] - 1) {
            next[0] = value;
        } else {
            ts.add(cur);
        }
    }
    
    public int[][] getIntervals() {
        int n = ts.size();
        int[][] ans = new int[n - 2][];
        Iterator<int[]> iterator = ts.iterator();
        iterator.next();
        for (int i = 0; i < n - 2; i++) {
            ans[i] = iterator.next();
        }
        return ans;
    }
}
```

## LC 354. 俄罗斯套娃信封问题

LIS 问题的贪心 + 二分解法。注意，这里的 LIS 问题是严格的 LIS 问题。

这里的维护的数组定义：$g[i]$ 记录的长度为 $i$ 的最长 LIS 中**最小**的信封高度，$g[i]$ 严格单调上升。

```latex
5 1 4 3 4 2
5 
1 
1 4 
1 3 
1 3 4 
1 2 4
```

代码：

```Java
public int maxEnvelopes(int[][] envelopes) {
	// LIS 问题
	int n = envelopes.length;
	Arrays.sort(envelopes, (o1, o2) -> {
		if (o1[0] == o2[0]) {
			return Integer.compare(o2[1], o1[1]);
		}
		return Integer.compare(o1[0], o2[0]);
	});
	int[] record = new int[n];
	record[0] = envelopes[0][1];
	int j = 0;
	for (int i = 1; i < n; i++) {
		int tar = envelopes[i][1];
		int left = 0;
		int right = j;
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (tar >= record[mid]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
		// 等于直接取代，LIS 问题是严格递增的
		if (right >= 0 && record[right] == tar) {
			record[right] = tar;
		} else {
			// 没找到才是这样的一段逻辑
			record[left] = tar;
			if (left > j) {
				j++;
			}
		}
	}
	return j + 1;
}
```

## LC 367. 有效的完全平方数

思考：

完全平方数在数轴上具有二分性。

代码：

```Java
public boolean isPerfectSquare(int num) {
	int left = 1;
	int right = num;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (mid >= num / mid) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	return left * left == num;
}
```

## LC 373. 查找和最小的 K 对数字

描述：

```latex
给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。
定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

e.g. nums1 = [1,2,3], nums2 = [5,8,10]
```

思考：多路归并

```latex
[1, [5,8,10]]
[2, [5,8,10]]
[3, [5,8,10]]

heap: 
[[1 + 5], [2 + 5], [3 + 5]] ans = [[1 + 5]]
[[2 + 5], [3 + 5], [1 + 8]] ans = [[1 + 5], [2 + 5]]
[[3 + 5], [1 + 8], [2 + 8]] ans = [[1 + 5], [2 + 5], [3 + 5]]
```

代码：

```Java
public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
	int n1 = nums1.length;
	int n2 = nums2.length;
	PriorityQueue<int[]> que = new PriorityQueue<>((o1, o2) ->{
		return Integer.compare(o1[0], o2[0]);
	});
	List<List<Integer>> ans = new ArrayList<>();
	for (int i = 0; i < Math.min(n1, k); i++) {
		que.offer(new int[]{nums1[i] + nums2[0], i, 0});
	}
	while (!que.isEmpty() && ans.size() < k) {
		int[] nums = que.poll();
		int i = nums[1], j = nums[2];
		ans.add(Arrays.asList(nums1[i], nums2[j]));
		if (j + 1 < n2) {
			que.offer(new int[] {nums1[i] + nums2[j + 1], i, j + 1});
		}
	}
	return ans;
}
```

## LC 436. 寻找右区间

```Java
public int[] findRightInterval(int[][] intervals) {
	int len = intervals.length;
	int[][] clone = new int[len][2];
	int[] ans = new int[len];
	Arrays.fill(ans, -1);
	// 将每个区间的左值记录下来，每个右值这个排序后的记录数组中查找
	for (int i = 0; i < len; i++) {
		clone[i][0] = intervals[i][0];
		clone[i][1] = i;
	}
	Arrays.sort(clone, (o1, o2) -> {
		return Integer.compare(o1[0], o2[0]);
	});
	//BinarySearch
	for (int i = 0; i < len; i++) {
		int val = intervals[i][1];
		int left = 0;
		int right = len - 1;
		// 这里是查找 <= 最接近的那个值
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (val >= clone[mid][0]) {
				left = mid + 1;
			} else if (val < clone[mid][0]) {
				right = mid - 1;
			}
		}
		if (right <= -1) {
			ans[i] = clone[left][1];
		} else if (clone[right][0] == val) {
			ans[i] = clone[right][1];
		} else {
			ans[i] = left >= len ? -1 : clone[left][1];
		}
	}
	return ans;
}
```

## LC 441. 排列硬币

思考：

```latex
1
1 1
1 1 0

这样看就可以了

0
1 1
1 1 1
```

代码：

```Java
public int arrangeCoins(int n) {
	// 公式为 n * (n + 1) / 2
	long left = 0, right = n;
	while (left <= right) {
		long mid = left + ((right - left) >> 1);
		if (mid * (mid + 1) / 2 >= n) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	return left * (left + 1) / 2 == n * 1L ? (int) left : (int) right;
}
```

## LC 475. 供暖器

描述：

```latex
冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
在加热器的加热半径范围内的每个房屋都可以获得供暖。
现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
说明：所有供暖器都遵循你的半径标准，加热的半径也一样。

输入：houses = [1,2,3,4], heaters = [1,4]
输出：1
```


代码：

```Java
public int findRadius(int[] houses, int[] heaters) {
	int ans = 0;
	Arrays.sort(heaters);
	for (int i = 0; i < houses.length; i++) {
		int left = 0;
		int right = heaters.length - 1;
		int val = houses[i];
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (val >= heaters[mid]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
		if (right < 0) {
			int dis = Math.abs(houses[i] - heaters[left]);
			ans = Math.max(ans, dis);
		} else {
			int dis1 = Math.abs(houses[i] - heaters[right]);
			// 看一下左边界有没有越界
			int dis2 = -1;
			if (left < heaters.length) {
				dis2 = Math.abs(houses[i] - heaters[left]);
			}
			if (dis2 == -1) {
				ans = Math.max(ans, dis1);
			} else {
				int tempDis = Math.min(dis1, dis2);
				ans = Math.max(ans, tempDis);
			}
		}
	}
	return ans;
}
```

## LC 497. 非重叠矩阵中的随机点

描述：

```latex
矩阵 i 的左下角和右上角的坐标被记录为
e.g. [[-2,-2,1,1],[2,2,4,6]]
随机从这些矩阵中选取一个点输出坐标
```

方法：

所有的点数记录为 $sum$ ，随机从 $[1,sum]$ 中生成一个整数，对应的代码为：`random.nextInt(sum) + 1`，然后确定这个数在哪个矩阵上，再在这个矩阵中随机生成一个点。

思路：前缀和 + 二分

代码：

```Java
class Solution {
    private Random random = new Random();
    int[][] rects = null;
    int[] sum = null;

    public Solution(int[][] rects) {
        int n = rects.length;
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            // 这是所有的点的个数
            sum[i + 1] = sum[i] + (rects[i][2] - rects[i][0] + 1) * (rects[i][3] - rects[i][1] + 1);
        }
        this.sum = sum;
        this.rects = rects;
    }
    
    public int[] pick() {
        int n = rects.length;
        int val = random.nextInt(sum[n]) + 1;
        int left = 0, right = n;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (val <= sum[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // 前缀和的下标要 - 1
        int[] cur = rects[left - 1];
        int x = random.nextInt(cur[2] - cur[0] + 1) + cur[0];
        int y = random.nextInt(cur[3] - cur[1] + 1) + cur[1];
        return new int[]{x, y};
    }
}
```

## LC 528. 按权重随机选择

描述：

```latex
给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。

请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。

例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），
而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。

```

代码：

```Java
class Solution {
    int[] sum;
    public Solution(int[] w) {
        // w[i] >= 1
        int n = w.length;
        sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + w[i];
        }
    }
    
    public int pickIndex() {
        int len = sum.length;
        // Math.random() 生成 [0, 1) 的一个类型为 double 的数
        int t = (int) ((Math.random() * sum[len - 1]) + 1);
        int left = 0, right = len - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (t <= sum[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left - 1;
    }
}
```

## LC 532. 数组中不同的 k-diff 数对

代码：

```Java
public int findPairs(int[] nums, int k) {
	// 本题要去重
	int ans = 0;
	Arrays.sort(nums);
	for (int i = 0; i < nums.length; i++) {
		if (i > 0 && nums[i] == nums[i - 1]) {
			continue;
		}
		int val = nums[i] + k;
		int left = i + 1;
		int right = nums.length - 1;
		while (left <= right) {
			int mid = left + ((right - left) / 2);
			if (val >= nums[mid]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
		if (right >= i + 1 && nums[right] == val) {
			ans++;
		}
	}
	return ans;
}
```


## LC 540. 有序数组中的单一元素

描述:

```latex
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
```

思考：

```latex
二分条件：分割点的左边相同数对第一个数的下标是偶数，分割点的左边相同数对第一个数的下标是奇数
```

代码：

```Java
public int singleNonDuplicate(int[] nums) {
	int n = nums.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (mid % 2 == 0) {
			if (mid + 1 < n && nums[mid] == nums[mid + 1]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		} else {
			if (mid + 1 < n && nums[mid] == nums[mid + 1]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		}
	}
	return nums[left];
}
```

## LC 646. 最长数对链

描述：

```latex
给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [lefti, righti] 且 lefti < righti 。

现在，我们定义一种 跟随 关系，当且仅当 b < c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。

找出并返回能够形成的 最长数对链的长度 。

你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
```

思考：

LIS 问题，这个问题要考虑 $left_{i}$  和 $right_{i}$ 。$rec$ 数组维护的是 $right_{i}$，根据 $left_{i}$ 找到待插入的区间

牢记 $rec$ 数组的定义：**$rec$ 数组维护的是 $[0-i]$ 最长 LIS 的最小值**。例如：

```latex
rec = [2,5,8]
2 5 [7,8] pairs[i] = [6,9]，这里就不能取代[7,8]的位置
```

代码：

```Java
public int findLongestChain01(int[][] pairs) {
	Arrays.sort(pairs, (o1, o2) -> {
		if (o1[0] == o2[0]) {
			return Integer.compare(o1[1], o2[1]);
		}
		return Integer.compare(o1[0], o2[0]);
	});
	int n = pairs.length, ans = 1;
	int[] rec = new int[n];
	Arrays.fill(rec, 0x3f3f3f3f);
	// 每次迭代都去找自己的位置
	for (int i = 0; i < n; i++) {
		int left = 0, right = i;
		int val = pairs[i][0];
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (val <= rec[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		}
		rec[left] = Math.min(rec[left], pairs[i][1]);
		ans = Math.max(ans, left + 1);
	}
	return ans;
}
```

## LC 658. 找到 K 个最接近的元素

描述：

```latex
给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。

整数 a 比整数 b 更接近 x 需要满足：

|a - x| < |b - x| 或者
|a - x| == |b - x| 且 a < b
```

代码：

```Java
public List<Integer> findClosestElements(int[] arr, int k, int x) {
	ArrayList<Integer> ans = new ArrayList<>();
	int left = 0;
	int right = arr.length - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (x >= arr[mid]) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	int anchor = -1;
	if (right < 0) {
		for (int i = 0; i < k; i++) {
			ans.add(arr[i]);
		}
		return ans;
	} else {
		if (left >= arr.length) {
			anchor = right;
		} else {
			anchor = Math.abs(arr[right] - x) <= Math.abs(arr[left] - x) ? right : left;
		}
	}
	ans.add(arr[anchor]);
	int i = anchor - 1;
	int j = anchor + 1;
	while (ans.size() < k) {
		if (i >= 0 && j <= arr.length - 1) {
			if (Math.abs(arr[i] - x) <= Math.abs(arr[j] - x)) {
				ans.add(arr[i]);
				i--;
			} else {
				ans.add(arr[j]);
				j++;
			}
		} else if (i >= 0) {
			// j 已经越界了
			ans.add(arr[i]);
			i--;
		} else {
			// i 已经越界了
			ans.add(arr[j]);
			j++;
		}
	}
	// 返回结果升序排好
	Collections.sort(ans);
	return ans;
}
```

## LC 668. 乘法表中第 k 小的数

描述：

```latex
乘法表：
1 2 3 4
2 4 6 8
3 6 9 12

数轴
1 2 2 3 3 4 4 6 6 8 9 12
          |
数轴上分割点的左半段 <=mid 的数（包括 mid）有 k 个
```

代码：

```Java
public int findKthNumber(int m, int n, int k) {
	// 1, 2, 3, 4, ..., m * n
	int left = 1, right = m * n;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		int count = mid / n * n;
		for (int i = mid / n + 1; i <= m; i++) {
			// 这里可以优化
			// mid / i >= n
			// count += Math.min(mid / i, n);
			count += mid / i;
		}
		if (count >= k) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	// 退出循环 count(left) >= k
	return left;
}
```

## LC 710. 黑名单上的随机数

描述：

```latex
给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。

优化你的算法，使它最小化调用语言 内置 随机函数的次数。

实现 Solution 类:

Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数
int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整数
```

思考：

前缀和 + 二分

首先统计排除黑名单后的区间，得到所有区间的长度，生成随机总数，找到区间，然后可以得到随机总数对应的这个区间的随机值。注意：这里选择的是区间的长度，$[0,0]$ 的区间长度是 1。

代码：

```Java
class Solution {
    Random random = new Random();
    List<int[]> list = new ArrayList<>();
    int[] preSum = null;
    int size = 0;

    public Solution(int n, int[] blacklist) {
        Arrays.sort(blacklist);
        int m = blacklist.length;
        if (m == 0) {
            list.add(new int[]{0, n - 1});
        } else {
            if (blacklist[0] != 0) {
                list.add(new int[]{0, blacklist[0] - 1});
            }
            for (int i = 1; i < m; i++) {
                int a = blacklist[i - 1] + 1;
                int b = blacklist[i] - 1;
                if (blacklist[i - 1] == blacklist[i] - 1) {
                    continue;
                } else {
                    list.add(new int[]{a, b});
                }
            }
            if (blacklist[m - 1] != n - 1) {
                list.add(new int[]{blacklist[m - 1] + 1, n - 1});
            }
        }
        size = list.size();
        preSum = new int[size + 1];
        for (int i = 0; i < size; i++) {
            int[] range = list.get(i);
            preSum[i + 1] = preSum[i] + range[1] - range[0] + 1;
        }
    }
    
    public int pick() {
        int val = random.nextInt(preSum[size]) + 1;
        int left = 1, right = size;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (val <= preSum[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        int[] ans = list.get(left - 1);
        int a = ans[0], b = ans[1], end = preSum[left];
        return b - (end - val);
    }
}
```

## LC 719. 找出第 K 小的数对距离

描述：

```latex
数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。
给你一个整数数组 nums 和一个整数 k ，数对由 nums[i] 和 nums[j] 组成且满足 0 <= i < j < nums.length 。
返回 所有数对距离中 第 k 小的数对距离。
```

代码：

```Java
public int smallestDistancePair(int[] nums, int k) {
	int len = nums.length;
	Arrays.sort(nums);
	int left = 0;
	int right = nums[len - 1] - nums[0];
	int ans = 0;
	// left, right, mid 都是dis
	while (left <= right) {
		int mid = left + ((right - left) / 2);
		// 统计小于等于 mid 的数对
		// 滑动窗口
		int i = 0;
		int count = 0;
		for (int j = 0; j < len; j++) {
			while (nums[j] - nums[i] > mid) {
				i++;
			}
			count += j - i;
		}
		if (count >= k) {
			ans = mid;
			right = mid - 1;
		} else if (count < k) {
			left = mid + 1;
		} 
	}
	return ans;
}
```

## LC 728. 自除数

描述：

```latex
自除数 是指可以被它包含的每一位数整除的数。
例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
自除数 不允许包含 0 。
给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。
```

代码：

```Java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> ans = new ArrayList<>();
        for (int i = left; i <= right; i++) {
            if (judge(i)) {
                ans.add(i);
            }
        }
        return ans;
    }

    private boolean judge(int num) {
        int rec = num;
        while (rec > 0) {
            int tail = rec % 10;
            // 除法/取模运算除数不能为 0
            if (tail == 0 || num % tail != 0) {
                return false;
            }
            rec /= 10;
        }
        return true;
    }
}
```

## LC 744. 寻找比目标字母大的最小字母

代码：

```Java
public char nextGreatestLetter(char[] letters, char target) {
	int n = letters.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (target >= letters[mid]) {
			left = mid + 1;
		} else{
			right = mid - 1;
		}
	}
	if (left >= n) {
		return letters[0];
	}
	return letters[left];
}
```

## LC 786. 第 K 小的素数分数

描述：

```latex
给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。

对于每对满足 0 <= i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。

那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。
```

代码：

```Java
public int[] kthSmallestPrimeFraction(int[] arr, int k) {
	int len = arr.length;
	double left = 0;
	double right = 1;
	while (left <= right) {
		double mid = (left + right) / 2;
		// 这里判断小于等于 mid 的数对有多少对
		int count = 0;
		int x = 0;
		int y = 1;
		int i = 0;
		for (int j = 1; j < len; j++) {
			while ((double) arr[i] / arr[j] <= mid) {
				if ((double) arr[i] / arr[j] > (double) x / y) {
					x = arr[i];
					y = arr[j];
				}
				i++;
			}
			count += i;
		}
		if (count == k) {
			return new int[]{x, y};
		} if (count < k) {
			left = mid;
		} else {
			right = mid;
		}
	}
	return new int[2];
}
```

## LC 792. 匹配子序列的单词数

描述：

```latex
给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。
字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。
例如， “ace” 是 “abcde” 的子序列。
```

思考：每个单词从前到后匹配会超时，单词出现的下标首先记录到 `HashMap` 中，每次查找的时候使用二分查找。

代码：

```Java
public int numMatchingSubseq(String s, String[] words) {
	char[] cs = s.toCharArray();
	int n = cs.length;
	int ans = 0;
	Map<Character, List<Integer>> map = new HashMap<>();
	for (int i = 0; i < n; i++) {
		List<Integer> list = map.getOrDefault(cs[i], new ArrayList<>());
		list.add(i);
		map.put(cs[i], list);
	}
	for (String word : words) {
		int idx = -1;
		char[] cw = word.toCharArray();
		int m = cw.length;
		int j = 0;
		for (; j < m; j++) {
			List<Integer> list = map.getOrDefault(cw[j], new ArrayList<>()); 
			if (list.size() == 0) {
				break;
			}
			int left = 0, right = list.size() - 1;
			// 去找严格大于 idx 的数，写成右边界
			while (left <= right) {
				int mid = left + ((right - left) >> 1);
				if (idx >= list.get(mid)) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
			// 去找严格大于 idx 的数
			if (left < list.size() && list.get(left) > idx) {
				idx = list.get(left);
			} else { 
				// 其它情况都是异常情况
				break;
			}
		}
		if (j == m) {
			ans++;
		}
	}
	return ans;
}
```

## LC 793. 阶乘函数后 K 个 0

思考：本题查看的是阶乘分解后 5 的个数。二分查找结尾有 K 个 0 的最大数，然后去找结尾有 K - 1 个 0 的最大数。

代码：

```Java
public int preimageSizeFZF(int k) {
	if (k <= 1) return 5;
	return f (k) - f (k - 1);
}

// 搜索 x 是值域
// x 是结尾有 k 个 0 的最大数 get(x) <= k
private int f (int k) {
	long left = 0, right = (long) 1e10;
	while (left <= right) {
		long mid = left + ((right - left) >> 1);
		if (k >= get(mid)) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	return (int) right;
}

private long get (long x) {
	int ans = 0;
	// 连续 / 5 再统计个数
	while (x != 0) {
		ans += x / 5;
		x /= 5;
	}
	return ans;
}
```

## LC 852. 山峰数组的峰顶索引

代码：

```Java
public int peakIndexInMountainArray(int[] arr) {
	int n = arr.length;
	int left = 0, right = n - 1;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (mid > 0 && arr[mid] <= arr[mid - 1]) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	return right;
}
```

## LC 875. 爱吃香蕉的珂珂 (&)

代码：

```Java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        Arrays.sort(piles);
        long left = 0, right = (long) 1e9;
        while (left <= right) {
            long mid = left + ((right - left) >> 1);
            if (getTime(piles, mid) <= h) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return (int) left;
    }

    private int getTime(int[] piles, long speed) {
	    if (speed == 0) {
		    return Integer.MAX_VALUE;
	    }
        int n = piles.length;
        if (speed >= piles[n - 1]) {
            return n;
        }
        int left = 0, right = n - 1, time = 0;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (speed >= piles[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        time += right + 1;
        for (int i = left; i < n; i++) {
            // 传入的参数肯定是 double 
            // += 可以自动类型转换
            // 累加就算是越界也会保留最大值
            // Math.ceil (1.0 / 0.0) 会优化，结果是 Integer.MAX_VALUE
            time += Math.ceil(piles[i] * 1.0 / speed);
        }
        return time;
    }
}
```

LC 878. 第 N 个神奇数字

描述：

```latex
一个正整数如果能被 a 或 b 整除，那么它是神奇的。

给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 1e9 + 7 取模 后的值。

```

代码：

```Java
class Solution {
    public int nthMagicalNumber(int n, int a, int b) {
        final int MOD = (int) 1e9 + 7;
        long left = 0, right = (long) 1e18;
        while (left <= right) {
            long mid = left + ((right - left) >> 1);
            int c = lcm(a, b);
            long cnt = mid / a + mid / b - mid / c;
            if (cnt >= n) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return (int) (left % MOD);
    }

    private int gcd (int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    private int lcm (int a, int b) {
        return a * b / gcd(a, b);
    }
}
```

## LC 911. 在线选举

描述：

```latex
给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。

对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。

在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。

实现 TopVotedCandidate 类：

TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。

```

思考：两个 `map`，一个 `map` 记录每个时刻每个候选人的得票数，另一个 `map` 记录每个时刻得票数最大的候选人。

代码：

```Java
class TopVotedCandidate {
    private int n;
    private int[] persons;
    private int[] times;
    private int[] record;
    private HashMap<Integer, Integer> rec; // 记录每个时刻最大得票数的候选人

    public TopVotedCandidate(int[] persons, int[] times) {
        this.n = persons.length;
        this.persons = persons;
        this.times = times;
        // 记录每个候选人的得票情况
        HashMap<Integer, Integer> map = new HashMap<>();
        rec = new HashMap<>();
        int maxVote = -1;
        int maxVotePerson = -1;
        for (int i = 0; i < n; i++) {
            // 记录哪个候选人，有多少张票
            map.put(persons[i], map.getOrDefault(persons[i], 0) + 1);
            // 相同也要更新
            if (map.get(persons[i]) >= maxVote) {
                maxVote = map.get(persons[i]);
                maxVotePerson = persons[i];
                rec.put(times[i], maxVotePerson);
            } else {
                rec.put(times[i], maxVotePerson);
            }
        }
    }
    
    public int q(int t) {
        record = new int[n];
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (t >= times[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        // 找的是右边界
        return rec.get(times[right]);
    }
}
```

## LC 926. 将字符串翻转到单调递增

描述：

```latex
如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。

给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。

返回使 s 单调递增的最小翻转次数。

输入：s = "010110" 
输出：2 ("0011")

输入：s = "00011000"
输出：2 ("000000")

```


思考：LIS

代码：

```Java
public int minFlipsMonoIncr(String s) {
	char[] cs = s.toCharArray();
	int n = cs.length;
	char[] rec = new char[n];
	rec[0] = cs[0];
	int j = 0;
	for (int i = 1; i < n; i++) {
		char val = cs[i];
		int left = 0, right = j;
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (val >= rec[mid]) {
				left = mid + 1;                    
			} else {
				right = mid - 1;
			}
		}
		rec[left] = val;
		if (left > j) {
			j++;
		}
	}
	return n - (j + 1);
}
```

## LC 1011. 在 D 天内送达包裹的能力

描述：
```latex
传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。
```

代码：

```Java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int left = 0, right = (int) 1e9;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (getDays(weights, mid) <= days) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int getDays(int[] weights, int capacity) {
        int n = weights.length;
        int temp = capacity;
        int days = 0;
        for (int i = 0; i < n; i++) {
            if (capacity < weights[i]) {
                return Integer.MAX_VALUE;
            }
            if (temp >= weights[i]) {
                temp -= weights[i];
            } else {
                days++;
                temp = capacity;
                temp -= weights[i];
            }
        }
        return days + 1;
    }
}
```

## LC 1044. 最长重复子串

描述：

```latex
给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 ""。
```

思考：

判断一个字符串是否出现过，不是 KMP 算法（找子串的下标），而是**字符串哈希**。

代码：

```Java
class Solution {
    private long[] p;
    private long[] h;
    public String longestDupSubstring(String s) {
        int P = 131, n = s.length();
        p = new long[n + 1];
        h = new long[n + 1];
        p[0] = 1;
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * P;
            h[i + 1] = h[i] * P + s.charAt(i);
        }
        int left = 0, right = n;
        String ans = "";
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            String cur = check(s, mid);
            if (cur.length() == 0) {
                right = mid - 1;
            } else {
                ans = cur;
                left = mid + 1;
            }
        }
        return ans;
    }

    private String check(String s, int len) {
        int n = s.length();
        Set<Long> set = new HashSet<>();
        for (int i = 1; i + len - 1 <= n; i++) {
            int j = i + len - 1;
            long hash = h[j] - h[i - 1] * p[j - i + 1];
            if (set.contains(hash)) {
                return s.substring(i - 1, j);
            }
            set.add(hash);
        }
        return "";
    }
}
```

## LC 1175. 质数排列

描述：

```latex
请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。
让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。
由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。
```

思考：质数个数的阶乘乘以非质数个数的阶乘。

代码：

```Java
class Solution {
    public int numPrimeArrangements(int n) {
        int MOD = (int) 1e9 + 7;
        List<Integer> list = getPrime();
        int l = 0, r = list.size() - 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            if (n >= list.get(mid)) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        // r + 1 是质数个数
        int a = r + 1, b = n - a;
        long ans = 1;
        for (int i = 1; i <= a; i++) {
            ans = ans * i % MOD;
        }
        for (int i = 1; i <= b; i++) {
            ans = ans * i % MOD;
        }
        return (int) ans;
    }

    private List<Integer> getPrime() {
        List<Integer> list = new ArrayList<>();
        for (int i = 2; i <= 100; i++) {
            boolean isPrime = true;
            for (int j = 2; j * j <= i; j++) {
                if (i % j == 0) {
                    isPrime = false;
                }
            }
            if (isPrime) {
                list.add(i);
            }
        }
        return list;
    }
}
```

## LC 1235. 规划兼职工作

代码：

```Java
public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
	List<int[]> list = new ArrayList<>();
	int n = startTime.length;
	for (int i = 0; i < n; i++) {
		list.add(new int[]{startTime[i], endTime[i], profit[i]});
	}
	list.sort((o1, o2) -> {
		return Integer.compare(o1[1], o2[1]);
	});
	int[] dp = new int[n];
	dp[0] = list.get(0)[2];
	int ans = dp[0];
	for (int i = 1; i < n; i++) {
		int[] nums = list.get(i);
		int start = nums[0];
		int end = nums[1];
		int prof = nums[2];
		int left = 0, right = i - 1;
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			int[] coms = list.get(mid);
			int val = coms[1];
			if (start >= val) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
		if (right < 0) {
			dp[i] = Math.max(dp[i - 1], prof);
		} else {
			dp[i] = Math.max(dp[i - 1], dp[right] + prof);
		}
		ans = Math.max(ans, dp[i]);
	}
	return ans;
}
```

## LC 1337. 矩阵中战斗力最弱的 K 行

描述：

```latex
给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。
```

代码：

```Java
public int[] kWeakestRows(int[][] mat, int k) {
	int m = mat.length, n = mat[0].length;
	int[] rec = new int[m];
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			int l = 0, r = n - 1;
			while (l <= r) {
				int mid = l + ((r - l) >> 1);
				if (mat[i][mid] == 1) {
					l = mid + 1;
				} else {
					r = mid - 1;
				}
			}
			rec[i] = l;
		}
	}
	int[][] recs = new int[m][2];
	for (int i = 0; i < m; i++) {
		recs[i][0] = rec[i];
		recs[i][1] = i;
	}
	Arrays.sort(recs, (a, b) -> {
		if (a[0] == b[0]) {
			return Integer.compare(a[1], b[1]);
		}
		return Integer.compare(a[0], b[0]);
	});
	// 返回的是索引位置
	int[] ans = new int[k];
	for (int i = 0; i < k; i++) {
		ans[i] = recs[i][1];
	}
	return ans;
}
```

## LC 1482. 制作 m 束花所需的最少天数

描述：

```latex
给你一个整数数组 bloomDay，以及两个整数 m 和 k 。
现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。
花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。
请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。
```

代码：

```Java
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        // 数值不越界
        int left = 0, right = (int) 1e9 + 7;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            // 最小找的是左边界
            if (getFlowers(bloomDay, mid, k) >= m) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left > (int) 1e9 + 7 ? -1 : left;
    }

    private int getFlowers(int[] bloomDay, int day, int k) {
        // 对于第 day 天，使用相邻的 k 朵花能做几朵花
        int n = bloomDay.length;
        int ans = 0;
        int j = 0;
        for (int i = 0; i < n;) {
            if (bloomDay[i] <= day) {
                j = i;
                while (j < n && bloomDay[j] <= day) {
                    j++;
                }
                int len = j - i;
                // 这里是除法不是取余数
                ans += (len / k);
                i = j;
            } else {
                i++;
            }
        }
        return ans;
    }
}
```

## LC 1608. 特殊数组的特征值

描述：

```latex
给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。

注意： x 不必 是 nums 的中的元素。

如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。
```

代码：

```Java
class Solution {
    public int specialArray(int[] nums) {
        int left = 0, right = 1000;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            // 这个是有单调性的，这里找的是右边界
            if (getCount(nums, mid) >= mid) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        // 最后的 right 满足 (getCount(nums, right) >= right);
        return right < 0 || right != getCount(nums, right)  ? -1 : right;
    }

    public int getCount(int[] nums, int x) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] >= x) {
                ans++;
            }
        }
        return ans;
    }
}
```

## LC 1713. 得到子序列的最小操作次数

描述：

```latex
给你一个数组 target ，包含若干互不相同的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。

每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。

请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。

一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。
```

思考：

target 中没有重复元素，LCS 问题对应的就是 arr 中下标的 LIS 问题。

```latex
target = [6,4,8,1,3,2]
arr = [4,7,6,2,3,8,6,1]

4  7  6  2  3  8  6  1
1 -1  0  5  4  2  0  3

```

代码：

```Java
public int minOperations(int[] target, int[] arr) {
	int n = target.length, m = arr.length;
	HashMap<Integer, Integer> map = new HashMap<>();
	List<int[]> list = new ArrayList<>();
	for (int i = 0; i < n; i++) {
		map.put(target[i], i);
	}
	for  (int i = 0; i < m; i++) {
		if (map.containsKey(arr[i])) {
			list.add(new int[] {arr[i], map.get(arr[i])});
		}
	}
	// LIS
	if (list.size() == 0) {
		return n;
	}
	int[] rec = new int[list.size()];
	rec[0] = list.get(0)[1];
	int j = 0;
	for (int i = 1; i < list.size(); i++) {
		int[] item= list.get(i);
		int val = item[1];
		int left = 0, right = j;
		while (left <= right) {
			int mid = left + ((right - left) >> 1);
			if (val <= rec[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		}
		rec[left] = val;
		if (left > j) {
			j++;
		}
	}
	return n - (j + 1);
}
```

## LC 1751. 最多可以参加的会议数目 II

描述：

```latex
给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。

你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。

请你返回能得到的会议价值 最大和 。
```


代码：

```Java
public int maxValue(int[][] events, int k) {
	Arrays.sort(events, (a, b) -> {
		return Integer.compare(a[1], b[1]);
	});
	int n = events.length;
	int[][] dp = new int[n][k + 1];
	// 无效状态是 0
	dp[0][1] = events[0][2];
	int ans = dp[0][1];
	for (int i = 1; i < n; i++) {
		int start = events[i][0];
		for (int j = 1; j <= k; j++) {
			int left = 0, right = i - 1;
			while (left <= right) {
				// 严格小于
				int mid = left + ((right - left) >> 1);
				if (start > events[mid][1]) {
					left = mid + 1;
				} else {
					right = mid - 1;
				}
			}
			if (right < 0) {
				dp[i][j] = Math.max(dp[i - 1][j], events[i][2]);
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[right][j - 1] + events[i][2]);
			}
			ans = Math.max(ans, dp[i][j]);
		}
	}
	return ans;
}
```

## LC 1760. 袋子里最少数目的球

描述：

```latex
给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。

你可以进行如下操作至多 maxOperations 次：

选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。
比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。
你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。

请你返回进行上述操作后的最小开销。
```

思考：最大值最小化，假设开销（单个袋子里球数目的最大值）是 $x$，$f(x)$ 表示达到 $x$ 的操作次数，是一个单调递减的函数。

代码：

```Java
class Solution {
    public int minimumSize(int[] nums, int maxOperations) {
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(max, nums[i]);
        }
        int left = 1, right = max;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (getOperationTimes(nums, mid) <= maxOperations) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int getOperationTimes(int[] nums, int value) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans += (nums[i] - 1) / value;
        }
        return ans;
    }
}
```

## LC 1802. 有界数组中指定下标处的最大值

描述：

```latex
给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：
nums.length == n
nums[i] 是 正整数 ，其中 0 <= i < n
abs(nums[i] - nums[i+1]) <= 1 ，其中 0 <= i < n-1
nums 中所有元素之和不超过 maxSum
nums[index] 的值被 最大化
返回你所构造的数组中的 nums[index] 。
```

思考：贪心 + 二分

```latex
1 2 2 2 
相同的 peak 值，在满足 sum <= maxSum 时， peak 值更小。
1 1 2 1
```

```Java
class Solution {
    public int maxValue(int n, int index, int maxSum) {
        int left = 0, right = maxSum;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (getSum(n, index, maxSum, mid)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }

    private boolean getSum(int n, int index, int maxSum, int peak) {
        // 数值会越界，考虑一下 long
        if (peak == 0) {
            return true;
        }
        long count = 0;
        // 用数学公式求和
        if (index + 1 >= peak) {
            // 整数会越界的
            count += (long) peak * (peak + 1) / 2;
            count += (index + 1 - peak);
        } else {
            int start = peak - index;
            count += (long) (start + peak) * (index + 1) / 2;
        }
        if (count > maxSum) {
            return false;
        }
        if (n - index < peak) {
            int end = peak - (n - index - 1);
            count += (long) (peak + end) * (n - index) / 2;
        } else {
            count += (long) peak * (peak + 1) / 2;
            count += n - index - peak;
        }
        count -= peak;
        return count <= maxSum;
    }

    private boolean getSum01(int n, int index, int maxSum, int peak) {
        if (peak == 0) {
            return true;
        }
        long count = 0;        
        if (index + 1 >= peak) {
            count += peak * (peak + 1) / 2;
            count += (index + 1 - peak);
        } else {
            int start = peak - index;
            count += (start + peak) * (index + 1) / 2;
        }
        if (count > maxSum) {
            return false;
        }
        if (n - index < peak) {
            int end = peak - (n - index - 1);
            count += (peak + end) * (n - index) / 2;
        } else {
            count += peak * (peak + 1) / 2;
            count += n - index - peak;
        }
        count -= peak;
        return count <= maxSum;    
    }
}
```

## LC 1818. 绝对差值和

描述：

```latex
给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。
数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 <= i < n）的 总和（下标从 0 开始）。
你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。
在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。

```

代码：

```Java
class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        int MOD = (int) 1e9 + 7;
        int count = 0;
        int n = nums1.length;
        int[] copy = nums1.clone();
        Arrays.sort(copy);
        int maxAbsDiff = -1;
        for (int i = 0; i < n; i++) {
            int diff = Math.abs(nums1[i] - nums2[i]);
            count += diff;
            count %= MOD;
            int minDiff = getMinAbsDiff(copy, nums2, i);
            if (diff - minDiff > maxAbsDiff) {
                maxAbsDiff = diff - minDiff;
            }
        }
        // 应该是每个数的差值
        if (count < maxAbsDiff) {
            count += MOD;
            count -= maxAbsDiff;
            count %= MOD;
        } else {
            count -= maxAbsDiff;
        }
        return count;
    }

    private int getMinAbsDiff(int[] copy, int[] nums2, int index) {
        int n = nums2.length;
        int left = 0, right = n - 1;
        int tar = nums2[index];
        int val = 0;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (copy[mid] <= tar) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        if (right < 0) {
            val = Math.abs(copy[left] - tar);
        } else if (left >= n) {
            val = Math.abs(copy[right] - tar);
        } else {
            val = Math.min(Math.abs(copy[left] - tar), Math.abs(copy[right] - tar));
        }
        return val;
    }
}
```

## LC 1894. 找到需要补充粉笔的学生编号

描述：

```latex
一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
请你返回需要 补充 粉笔的学生 编号 。
```

思考：这里计算的是总和，思路就是前缀和 + 二分。

代码：

```Java
public int chalkReplacer(int[] chalk, int k) {
	int n = chalk.length;
	long[] preSum = new long[n + 1];
	for (int i = 0; i < n; i++) {
		preSum[i + 1] = preSum[i] + chalk[i];
	}
	int last = (int) (k % preSum[n]);
	// left 是前缀和，实际的下标要 - 1
	int left = 0, right = n;
	while (left <= right) {
		int mid = left + ((right - left) >> 1);
		if (preSum[mid] <= last) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	return left - 1;
}
```


## LC 2055. 蜡烛之间的盘子

描述：

```latex
给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。

比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。
请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。
```

思路：

- 查找区间和，前缀和。
- 查找合法区间两侧盘子的下标，二分。

代码：

```Java
class Solution {
    public int[] platesBetweenCandles(String s, int[][] queries) {
        char[] cs = s.toCharArray();
        int n = cs.length, m = queries.length;
        int[] preSum = new int[n + 1];
        int[] ans = new int[m];
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            preSum[i + 1] = preSum[i] + (cs[i] == '*' ? 1 : 0);
            if (cs[i] == '|') {
                list.add(i);
            }
        }
        for (int i = 0; i < m; i++) {
            int start = queries[i][0];
            int end = queries[i][1];
            int left = 0, right = list.size() - 1;
            while (left <= right) {
                int mid = left + ((right - left) >> 1);
                if (start <= list.get(mid)) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            // 没找到比左边界更大的 [4,5,8,11] start = 30
            if (left >= list.size()) {
                ans[i] = 0;
                continue;
            }
            int leftAnchor = list.get(left);
            left = 0;
            right = list.size() - 1;
            while (left <= right) {
                int mid = left + ((right - left) >> 1);
                if (list.get(mid) <= end) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            if (right < 0) {
                ans[i] = 0;
                continue;
            }
            int rightAnchor = list.get(right);
            int val = preSum[rightAnchor + 1] - preSum[leftAnchor];
            ans[i] = val <= 0 ? 0 : val;
        }
        return ans;
    }
}
```

