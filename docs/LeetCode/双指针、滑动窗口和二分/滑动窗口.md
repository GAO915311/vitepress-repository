# 方法论

滑动窗口的流程：
1. 滑动窗口右移，数据结构记录右移结果。
2. 滑动窗口左移，数据结构记录左移结果。

常见的数据结构有 `Map`, `Set`, `PriorityQueue`（优先队列，堆）

滑动窗口的含义：以 `j` 为结尾的，滑动窗口 `[i, j]` 一定是满足这个条件的。

## 滑动窗口小于等于/大于等于某个量的思考：

**滑动窗口要满足小于等于某个量**：滑动窗口右扩是在背离这个条件，左缩是在满足这个条件，这就是条件的二段性。
滑动窗口右扩 `map.size()` 是会变大（可能不变），或者 `map.size()` 固定，让 `map` 中记录的数变大。

常见的条件：
- 滑动窗口中每个字符最多只出现一次（`set` 去重）。
- 滑动窗口中最多只能出现 `K` 种字符 （`map.size() <= K`）。
- `map.size()` 固定，`map` 中每一个元素出现的次数 `<= K`。

逻辑：
- 不满足要求，先左缩，确定 `i`，使得滑动窗口满足要求再处理。
- 在右扩中统计，统计的是==最长==的量。

例如：
- [LC 3. 无重复字符的最长子串](#lc-3-无重复字符的最长子串)维护的是 `map (set)` 中每个字符小于等于 1。
- [#LC 904. 水果成篮](#lc-904-水果成篮)维护的是 `map.size() <= 2`。
- [LC 992. K 个不同整数的子数组（重点）](#lc-992-k-个不同整数的子数组重点)维护的是 `map.size() <= 2`。

**滑动窗口要满足大于等于某个量**： 滑动窗口左缩是在背离这个条件，右扩是在迎合这个条件。

例如：
- 某种字符最少出现一次/出现次数**大于等于**某个量。

逻辑：
- 不满足要求，滑动窗口右扩，什么逻辑也没有。
- 满足要求，在 `while` 循环中滑动窗口左缩。
- 在左缩中统计，统计的是==最短==的量。

例如：
- [LC 76. 最小覆盖子串](#lc-76-最小覆盖子串)维护的是 `map` 中所有字符的出现次数都要大于等于 `rec` 中所有字符的出现次数。

固定长度的滑动窗口，环形滑动窗口。
- 滑动窗口的最大（小）值：**单调队列**。
- 滑动窗口的中位数：**堆**。

字母异位词：比较两个 `map` 是否相同。

# 题目

## LC 3. 无重复字符的最长子串

描述：s = “abcabcab”，无重复字符的最长子串是 “abc”。

解决：维护 `HashMap (HashSet)` 中所有的元素出现的次数均为 1。“abca”，`s[j]` 出现了两次就需要收缩滑动窗口。

## LC 30. 串联所有单词的子串

描述：words = [“foo”, “bar”]，所有的字符串**长度相同**，串联子串就是 words 中所有字符串排列组合后的字符串，e.g. “foobar”, “barfoo”。现在 s = “barfoothefoobarman”,  返回串联子串在 s 中开始的索引。上述案例的答案为 [0, 9]。

解决：类比 LC 438. 有效的字母异位词，现在是单词异位。`HashMap<String,Integer> map`  中记录所有单词出现的次数，`map.size() > words.length` 或者 `j-i` 越界了，开始缩小滑动窗口。

```latex
barfoothefoobarman    barfoothefoobarman    barfoothefoobarman
i  j				    i				         i
barfoothefoobarman
i     j
barfoothefoobarman
   i  j
```

代码：
```java
public List<Integer> findSubstring(String s, String[] words) {
    // words 中的字符可能会重复
    ArrayList<Integer> ans = new ArrayList<>();
    int n = s.length();
    int m = words.length;
    int w = words[0].length();
    // words 中每个单词的出现次数
    HashMap<String, Integer> map = new HashMap<>();
    for (String word : words) {
        map.put(word, map.getOrDefault(word, 0) + 1);
    }
    for (int i = 0; i < w; i++) {
        HashMap<String, Integer> temp = new HashMap<>();
        for (int j = i; j + w <= n; j += w) {
            String cur = s.substring(j, j + w);
            temp.put(cur, temp.getOrDefault(cur, 0) + 1);
            // 缩小滑窗
            if (j >= i + m * w) {
                int idx = j - m * w;
                String prev = s.substring(idx, idx + w);
                // 滑动窗口（固定大小）的左移体现为 temp 删除左边越界的单词
                if (temp.get(prev) == 1) {
                    // 这里如果是 0 的话应该移除，e.g. the map 中没有 the 不需要记录为 0
                    temp.remove(prev);
                } else {
                    temp.put(prev, temp.get(prev) - 1);
                }
            }
            if (temp.equals(map)) {
                ans.add(j - (m - 1) * w);
            }
        }
    }
    return ans;
}
```

## LC 76. 最小覆盖子串

描述：

```latex
S = "ADOBECODEBANC", t = "ABC" 求 s 中包含 t 中所有字母的长度最小的子串
```

解决：

```latex
A->1, B->1, C->1
```

滑动窗口收缩的条件：当 s 中出现的 A，B，C 的个数全部大于等于 t 中 A， B， C 的个数

```
ADOBEC ->
DOBEC ->
DOBECODEBA ->
ODEBA ->
ODEBANC ->
BANC
```

代码：

```java
Public String minWindow (String s, String t) {
    HashMap<Character, Integer> rec = new HashMap<>();
    for (int i = 0; i < t.length (); i++) {
        char ch = t.charAt (i);
        Rec.Put (ch, rec.GetOrDefault (ch, 0) + 1);
    }
    int need = rec.Size ();
    HashMap<Character, Integer> map = new HashMap<>();
    String ans = "";
    int minLen = Integer. MAX_VALUE, valid = 0;
    for (int i = 0, j = 0; j < s.length (); j++) {
        char c = s.charAt (j);
        if (rec.ContainsKey (c)) {
            Map.Put (c, map.GetOrDefault (c, 0) + 1);
            // 本来就是多的，还加吗？
            // 这里只有相同才加入
            // 整形包装类用 equals 判断是否相等，这是 Java 基础
            If (map.Get (c). Equals (rec.Get (c))) {
                Valid++;
            }
        }
        // 只要 map 对应的字母个数 >=  rec 对应的字母个数就要缩
        // map 中满足条件的字母的个数 valid 来计数
        while (valid == need) { 
            if (j - i + 1 < minLen) {
                MinLen = j - i + 1;
                ans = s.substring (i, j + 1);
            }
            char left = s.charAt (i);
            if (rec.ContainsKey (left)) {
                Map.Put (left, map.Get (left) - 1);
                if (map.Get (left) < rec.Get (left)) {
                    valid--;
                }
            }
            i++;
        }
    }
    Return ans;
}
```

细节：每次比较可以遍历 map 和 rec，也可以使用 valid 优化

```latex
A -> 2
B -> 2
C -> 1
```

当 map 中 A 的个数等于 rec 中 A 的个数，valid 加 1，大于的话 valid 不做处理，map 中 A 的数量是满足条件的。

当 map 中 A 的个数小于 rec 中 A 的个数，valid 减 1。



## LC 187. 重复的 DNA 序列

## LC 219. 存在重复元素 II

代码：

```java
Public boolean containsNearbyDuplicate (int[] nums, int k) {
    Int len = nums. Length;
    HashSet<Integer> set = new HashSet<>();
    For (int i = 0, j = 0; j < len; j++) {
        If (j - i + 1 > k + 1) {
            Set.Remove (nums[i]);
            I++;
        }
        If (set.Contains (nums[j])) {
            Return true;
        }
        Set.Add (nums[j]);
    }
    Return false;
}

Public boolean containsNearbyDuplicate (int[] nums, int k) {
    Set<Integer> set = new HashSet<Integer>();
    int length = nums. Length;
    for (int i = 0; i < length; i++) {
        if (i > k) {
            set.remove (nums[i - k - 1]);
        }
        if (! Set.Add (nums[i])) {
            Return true;
        }
    }
    return false;
}
```



## LC 220. 存在重复元素 III

描述：

```latex
Nums indexDiff valueDiff
是否能找到 i != j 且 abs (i - j) <= indexDiff 且 abs (nums[i] - nums[j]) <= valueDiff
```

代码：

```java
Public boolean containsNearbyAlmostDuplicate (int[] nums, int indexDiff, int valueDiff) {
    TreeSet<Integer> set = new TreeSet<>();
    For (int j = 0; j < nums. Length; j++) {
        // 滑窗大小满足条件
        If (j > indexDiff) {
            Set.Remove (nums[j - indexDiff - 1]);
        }
        // 每次都要遍历，查找的时间复杂度要降为 O (logn)，使用数据结构 TreeSet
        Integer ceil = set.Ceiling (nums[j]);
        Integer floor = set.Floor (nums[j]);
        If (ceil != null && Math.Abs (nums[j] - ceil) <= valueDiff) return true;
        If (floor != null && Math.Abs (nums[j] - floor) <= valueDiff) return true;
        Set.Add (nums[j]);
    }
    Return false;
}
```

滑窗的大小是固定的

```latex
[1,2,3,1,2] k = 3
[1], 2,3,1,2
[1,2], 3,1,2
[1,2,3], 1,2
1,[2,3,1], 2
1,2,[3,1,2]
```

固定大小的滑动窗口

滑动窗口左缩，然后再判断



## LC 239. 滑动窗口的最大值 (单调队列)

```java
Public int[] maxSlidingWindow (int[] nums, int k) {
    // 单调队列
    LinkedList<Integer> MonoQue = new LinkedList<>();
    Int[] ans = new int[nums. Length - k + 1];
    For (int i = 0, j = 0; j < nums. Length; j++) {
        // 更新右边的数据
        While (! MonoQue. IsEmpty () && MonoQue. PeekLast () < nums[j]) {
            MonoQue. PollLast ();
        }
        MonoQue. OfferLast (nums[j]);
        // 更新左边的数据
        If (j >= k) {
            If (MonoQue. PeekFirst () == nums[j - k]) {
                MonoQue. PollFirst ();
            }
        }
        // 记录
        If (j >= k - 1) {
            Ans[j - k + 1] = MonoQue. PeekFirst ();
        }
    }
    Return ans;
}
```

## LC 395. 至少有 K 个重复字符的最长子串

描述：

```latex
给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 s 仅由小写字母组成。
输入：s = "ababbc", k = 2
输出：5 (“ababb”的长度)
```

思考:

滑动窗口中要求每一字符出现的次数大于等于 `k`，没有二段性质。
例如： `k = 2, “aba”` 右扩。当 `“abab”` 满足条件时，求最长长度还是右扩。

s 仅由小写字母组成。将条件改成子串中字符种类 `map.size()<=1,2,3,...,26`（记住这个条件），然后再统计满足条件的子串最长长度。

还有一种方法：分治算法。

代码：
```Java
public int longestSubstring(String s, int k) {
	char[] cs = s.toCharArray();
	int n = cs.length;
	int ans = 0;
	for (int p = 1; p <= 26; p++) {
		HashMap<Character, Integer> map = new HashMap<>();
		for (int i = 0, j = 0; j < n; j++) {
			map.put(cs[j], map.getOrDefault(cs[j], 0) + 1);
			while (i <= j && map.size() > p) {
			   map.put(cs[i], map.get(cs[i]) - 1);
			   if (map.get(cs[i]).equals(0)) {
				   map.remove(cs[i]);
			   }
			   i++;
			}
			if (check(map, k)) {
				ans = Math.max(ans, j - i + 1);
			}
		}
	}
	return ans;
}

private boolean check(HashMap<Character, Integer> map, int k) {
	for (Map.Entry<Character, Integer> entry : map.entrySet()) {
		if (entry.getValue() < k) {
			return false;
		}
	}
	return true;
}

public int longestSubstring01(String s, int k) {
	return recursion(s.toCharArray(), k ,0, s.length() - 1);
}

private int recursion(char[] chars, int k, int i, int j) {
	if (j - i + 1 < k) {
		return 0;
	}
	char[] record = new char[26];
	for (int idx = i; idx <= j; idx++) {
		record[chars[idx] - 'a']++;
	}
	int start = i;
	int end = j;
	// 这里指针的移动会破坏条件
	while (start <= end && record[chars[start] - 'a'] < k) {
		start++;
	}
	while (start <= end && record[chars[end] - 'a'] < k) {
		end--;
	}
	// 得到子串重新处理
	// 不要判断条件也可以，无非开了下一个栈
	// if (end - start + 1 < k) return 0;
	for (int idx = start; idx <= end; idx++) {
		// 找到第一个不满足条件的字符的位置，分成两段递归求解
		if (record[chars[idx] - 'a'] < k) {
			return Math.max(recursion(chars, k, start, idx- 1),
						recursion(chars, k , idx + 1, end));
		}
	}
	return end - start + 1;
}
```


## LC 396. 旋转函数

描述：

```latex
Nums = [4,3,2,6]; copy = [4,3,2,6,4,3,2,6]
0 * 4 + 1 * 3 + 2 * 2 + 3 * 6 = 25
0 * 3 + 1 * 2 + 2 * 6 * 3 * 4 = 26
...
```

推导:

```latex
Prev = nums[i - 1] * 0 + nums[i] * 1 + ... + nums[i + n - 2] * (n - 1)
Cur = nums[i] * 0 + nums[i + 1] * 1 + ... + nums[i + n - 2] * (n - 2) + nums[i + n - 1] * (n - 1)
Prev - cur = nums[i] + nums[i + 1] + ... + nums[i + n - 2] - nums[i + n - 1] * (n - 1)
```

结论：
$$
Cur = nums[i+n-1]\times (n-1) + \sum_{idx=i}^{i+n-2}nums[idx]
$$
要点：

- 前缀和
- 环形滑动窗口

代码：

```java
Public int maxRotateFunction (int[] nums) {
        Int n = nums. Length;
        Int[] copy = new int[n * 2];
        Int[] sum = new int[n * 2 + 1];
        For (int i = 0; i < n; i++) {
            Copy[i] = nums[i];
            Copy[i + n] = nums[i];
        }
        // 下面的操作都基于数组 copy
        For (int i = 0; i < n * 2; i++) {
            Sum[i + 1] = sum[i] + copy[i];
        }
        Int ans = 0;
        For (int i = 0; i < n; i++) {
            Ans += copy[i] * i;
        }
        Int cur = ans;
        For (int i = 1; i < n; i++) {
            Cur += copy[i + n - 1] * (n - 1);
            // [i, i + n - 2] 的和
            Cur -= sum[i + n - 1] - sum[i];
            Ans = Math. Max (ans, cur);
        }
        Return ans;
    }
```



## LC 424. 替换后的最长字符

描述：

```latex
给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。
在执行上述操作后，返回包含相同字母的最长子字符串的长度。
e.g. s = [A, A, B, A, B, B, A] k = 1
答案：4

```

代码：

```java
Public int characterReplacement (String s, int k) {
    char[] chars = s.toCharArray ();
    Int len = chars. Length;
    Int[] rec = new int[26];
    Int ans = 0;
    For (int left = 0, right = 0; right < len; right++) {
        Rec[chars[right] - 'A']++;
        While (! Check (rec, k)) {
            // left 这个字符移出滑动窗口
            Rec[chars[left] - 'A']--;
            Left++;
        }
        Ans = Math. Max (ans, right - left + 1);
    }
    Return ans;
}

Private boolean check (int[] rec, int k) {
    // 出现最多的次数
    Int maxTimes = 0;
    Int sum = 0;
    For (int i = 0; i < 26; i++) {
        Sum += rec[i];
        MaxTimes = Math. Max (maxTimes, rec[i]);
    }
    Return sum - maxTimes <= k;
}
```


## LC 438. 有效的字母异位词（重点）

思考：
```LaTeX
这里滑动窗口的长度是固定的。直接比较两个 map 即可，这里使用了数组优化。

rec:
a b c d ... z
1 1 1 0 ... 0

map:
a b c d ... z
1 0 0 1 ... 0（左缩）

map 中不能有一个字母的记录比 rec 中对应的字母记录大。
```

代码：
```java
public List<Integer> findAnagrams (String s, String p) {
    List<Integer> ans = new ArrayList<>();
    int n = s.length (), m = p.length ();
    Int[] c 1 = new int[26], c 2 = new int[26];
    for (int i = 0; i < m; i++) c 2[p.charAt (i) - 'a']++;
    For (int l = 0, r = 0; r < n; r++) {
        c 1[s.charAt (r) - 'a']++;
        if (r - l + 1 > m) c 1[s.charAt (l++) - 'a']--;
        If (check (c 1, c 2)) ans. Add (l);
    }
    Return ans;
}
Boolean check (int[] c 1, int[] c 2) {
    For (int i = 0; i < 26; i++) {
        If (c 1[i] != c 2[i]) return false;
    }
    Return true;
}
```



## LC 480. 滑动窗口的中位数（双优先队列+延迟删除）

待删除的元素放入 delayMap 中记录，真正的删除操作要看堆顶的元素是否在 delayMap 中 （堆中只有堆顶的元素可以删除）。

代码：

```java
Class Solution {
    Public double[] medianSlidingWindow (int[] nums, int k) {
        DualHeap dh = new DualHeap (k);
        For (int i = 0; i < k; ++i) {
            Dh. Insert (nums[i]);
        }
        Double[] ans = new double[nums. Length - k + 1];
        Ans[0] = dh. GetMedian ();
        For (int i = k; i < nums. Length; ++i) {
            Dh. Insert (nums[i]);
            Dh. Erase (nums[i - k]);
            Ans[i - k + 1] = dh. GetMedian ();
        }
        Return ans;
    }
}

Class DualHeap {
    // 大根堆，维护较小的一半元素
    private PriorityQueue<Integer> small;
    // 小根堆，维护较大的一半元素
    private PriorityQueue<Integer> large;
    // 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数
    private Map<Integer, Integer> delayed;

    Private int k;
    // small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素
    Private int smallSize, largeSize;

    Public DualHeap (int k) {
        this. Small = new PriorityQueue<Integer>(new Comparator<Integer>() {
            Public int compare (Integer num 1, Integer num 2) {
                Return num 2. CompareTo (num 1);
            }
        });
        this. Large = new PriorityQueue<Integer>(new Comparator<Integer>() {
            Public int compare (Integer num 1, Integer num 2) {
                Return num 1. CompareTo (num 2);
            }
        });
        this. Delayed = new HashMap<Integer, Integer>();
        This. K = k;
        This. SmallSize = 0;
        This. LargeSize = 0;
    }

    Public double getMedian () {
        Return (k & 1) == 1 ? Small. Peek () : ((double) small. Peek () + large. Peek ()) / 2;
    }

    Public void insert (int num) {
        If (small. IsEmpty () || num <= small. Peek ()) {
            Small. Offer (num);
            ++smallSize;
        } else {
            Large. Offer (num);
            ++largeSize;
        }
        MakeBalance ();
    }

    Public void erase (int num) {
        // 待删除的数开始影响结果了才删除
        Delayed. Put (num, delayed. GetOrDefault (num, 0) + 1);
        If (num <= small. Peek ()) {
            // 有效元素个数
            --smallSize;
            If (num == small. Peek ()) {
                Prune (small);
            }
        } else {
            --largeSize;
            If (num == large. Peek ()) {
                Prune (large);
            }
        }
        MakeBalance ();
    }

    // 不断地弹出 heap 的堆顶元素，并且更新 delayed
    // 保证堆顶的元素
    private void prune (PriorityQueue<Integer> heap) {
        // 堆顶的元素已经在 delayed 中了
        While (! Heap. IsEmpty ()) {
            // 堆顶的元素在不在 delayed 中被记录
            Int num = heap. Peek ();
            If (delayed. ContainsKey (num)) {
                Delayed. Put (num, delayed. Get (num) - 1);
                If (delayed. Get (num) == 0) {
                    Delayed. Remove (num);
                }
                Heap. Poll ();
            } else {
                Break;
            }
        }
    }

    // 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求
    Private void makeBalance () {
        If (smallSize > largeSize + 1) {
            // small 比 large 元素多 2 个
            Large. Offer (small. Poll ());
            --smallSize;
            ++largeSize;
            // small 堆顶元素被移除，需要进行 prune
            Prune (small);
        } else if (smallSize < largeSize) {
            // large 比 small 元素多 1 个
            Small. Offer (large. Poll ());
            ++smallSize;
            --largeSize;
            // large 堆顶元素被移除，需要进行 prune
            Prune (large);
        }
    }
}
```



## LC 567. 字符串的排列

描述：

```latex
给你两个字符串 s 1 和 s 2 ，写一个函数来判断 s 2 是否包含 s 1 的排列。如果是，返回 true ；否则，返回 false 。
换句话说，s 1 的排列之一是 s 2 的子串。
```

要点：

固定的滑动窗口，比较两个 map 是否相等

代码：

```java
Public boolean checkInclusion (String s 1, String s 2) {
    HashMap<Character, Integer> rec = new HashMap<>();
    Int n = s 1. Length ();
    For (int i = 0; i < n; i++) {
        Char ch = s 1. CharAt (i);
        Rec. Put (ch, rec. GetOrDefault (ch, 0) + 1);
    }
    HashMap<Character, Integer> map = new HashMap<>();
    For (int i = 0; i < s 2. Length (); i++) {
        Char c = s 2. CharAt (i);
        Map. Put (c, map. GetOrDefault (c, 0) + 1);
        If (i >= n) {
            Int count = map. Get (s 2. CharAt (i - n));
            If (count == 1) {
                Map. Remove (s 2. CharAt (i - n));
            } else {
                Map. Put (s 2. CharAt (i - n), count - 1);
            }
        }
        If (rec. Equals (map)) {
            Return true;
        }
    }
    Return false;
}
```


## LC 594. 最长和谐子序列

描述：
```latex
和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是 1。
现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
```

要点：排序+滑动窗口/哈希计数

代码：
```java
Public int findLHS (int[] nums) {
    // 滑动窗口
    Arrays. Sort (nums);
    int begin = 0;
    int ans = 0;
    for (int end = 0; end < nums. Length; end++) {
        while (nums[end] - nums[begin] > 1) {
            begin++;
        }
        if (nums[end] - nums[begin] == 1) {
            ans = Math.Max(ans, end - begin + 1);
        }
    }
    return ans;
}
```

## LC 632. 最小区间

描述：
```latex
你有 k 个非递减排列的整数列表。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a, b] 比 [c, d] 小。
输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出：[20,24]
```

思考：
```
0 4 5 9...
1 0 2 1...
```
求包含 `[0-k]` 的个数均大于等于 1 的区间差值最小的滑动窗口。

代码：
```Java
public int[] smallestRange (List<List<Integer>> nums) {
	Int k = nums. Size ();
	Int[] rec = new int[k];
	Int count = 0;
	List<int[]> items = new ArrayList<>();
	for (List<Integer> list : nums) {
		For (int num : list) {
			Int[] pair = {num, count};
			Items. Add (pair);
		}
		Count++;
	}
	items.sort ((o1, o2) -> {
		if(o1[0] == o2[0]) {
			return Integer.Compare (o1[1], o2[1]);
		} 
		return Integer.Compare(o1[0], o2[0]);
	});
	int n = items.Size (), range = Integer.MAX_VALUE;
	int[] ans = new int[2];
	For (int i = 0, j = 0; j < n; j++) {
		int[] right = items.get(j);
		rec[item[1]]++;
		While (i <= j && check (rec)) {
			Int[] left = items. Get (i);
			If (right[0] - start[0] < range) {
				range = right[0] - left[0];
				ans[0] = left[0];
				ans[1] = right[0];
			}
			rec[left[1]]--;
			i++;
		}
	}
	return ans;
}

Private boolean check (int[] rec) {
	For (int count : rec) {
		If (count <= 0) {
			Return false;
		}
	}
	Return true;
}
```

## LC 643. 子数组的最大平均数 I

固定滑动窗口

代码：

```java
Public double findMaxAverage (int[] nums, int k) {
    Int n = nums. Length;
    Int sum = 0;
    For (int i = 0; i < k; i++) {
        Sum += nums[i];
    }
    Int ans = sum;
    For (int i = k; i < n; i++) {
        Sum += nums[i];
        Sum -= nums[i - k];
        Ans = Math. Max (ans, sum);
    }
    Return ans * 1.0 / k;
}
```



## LC 904. 水果成篮（#）

描述：
```latex
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果种类。你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
你只有两个篮子，并且每个篮子只能装单一类型的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从每棵树（包括开始采摘的树）上恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的最大数目。
Fruits = [0,1,2,2]
答案：3
```

要点：

维护滑动窗口中 map. Size () <= 2

代码：
```java
Public int totalFruit (int[] fruits) {
    Int len = fruits. Length;
    Int left = 0;
    Int ans = 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    For (int right = 0; right < len; right++) {
        Map. Put (fruits[right], map. GetOrDefault (fruits[right], 0) + 1);
        while (left < len && map.size() > 2) {
            Map. Put (fruits[left], map. Get (fruits[left]) - 1);
            If (map. Get (fruits[left]) == 0) {
                Map. Remove (fruits[left]);
            }
	        left++;
        }
        Ans = Math. Max (ans, right - left + 1);
    }
    Return ans;
}
```

## LC 992. K 个不同整数的子数组（重点）

描述：

```latex
Nums = [1,2,1,2,3] K = 2
答案：7 [1,2], [1,2,1], [1,2,1,2], [2,1], [2,1,2], [1,2], [2,3]
```

要点：

类比水果成篮 `map.size() > K`，滑动窗口左移。

只能维护 `map.size() <= K`，即**最多**有 K 个不同整数的子数组。

刚好有 K 个不同整数的子数组个数 = **最多**有 K 个不同整数的子数组个数 - **最多**有 K - 1 个不同整数的子数组个数

代码：

```java
Public int subarraysWithKDistinct (int[] nums, int k) {
    Return find (nums, k) - find (nums, k - 1);
}

Private int find (int[] nums, int k) {
    If (k == 0) return 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    Int len = nums. Length;
    Int ans = 0;
    For (int left = 0, right = 0; right < len; right++) {
        // map 可以用数组代替
        Map. Put (nums[right], map. GetOrDefault (nums[right], 0) + 1);
        // 这里是等于, 判断 left <= right 下一次循环 left 是等待的索引 right = left
        // 避免边界条件 k = 0 的情况
        while (left <= right && map.size() > k) {
            Map. Put (nums[left], map. Get (nums[left]) - 1);
            If (map. Get (nums[left]) == 0) {
                Map. Remove (nums[left]);
            }
            Left++;
        }
        // 判断个数
        // 实际上滑动窗口只能记录 <= k 的个数
        // 线性 DP
        Ans += right - left + 1;
    }
    Return ans;
}
```



## LC 1004 最大连续 1 的个数 III

描述:

```latex
给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回数组中连续 1 的最大个数。
```

代码：

```java
Public int longestOnes (int[] nums, int k) {
    Int len = nums. Length;
    HashMap<Integer, Integer> map = new HashMap<>();
    Int ans = 0;
    For (int left = 0, right = 0; right < len; right++) {
        If (nums[right] == 0) {
            Map. Put (0, map. GetOrDefault (0, 0) + 1);
        }
        while (left <= right && !map.isEmpty() && map.get(0) > k) {
            If (nums[left] == 0) {
                Map. Put (0, map. Get (0) - 1);
            }
            Left++;
        }
        Ans = Math. Max (ans, right - left + 1);
    }
    Return ans;
}
```

## LC 1052.  爱生气的书店老板

代码：

```java
Public int maxSatisfied (int[] customers, int[] grumpy, int minutes) {
    Int n = customers. Length;
    Int ans = 0;
    For (int i = 0; i < n; i++) {
        If (grumpy[i] == 0) {
            Ans += customers[i];
            Customers[i] = 0;
        }
    }
    Int sum = 0;
    Int maxSum = 0;
    For (int i = 0; i < n; i++) {
        Sum += customers[i];
        If (i >= minutes) {
            Sum -= customers[i - minutes];
        }
        MaxSum = Math. Max (maxSum, sum);
    }
    Ans += maxSum;
    Return ans;
}
```

## LC 1156. 单字符重复子串的最大长度

描述：

```latex
如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。
给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。
输入：text="ababa"
输出：6
输入：text=“aaabaaa"
输出：4
```

思考：
滑动窗口遍历的是连续的相同字符 `a` ，考虑能否拼接。

```latex
例如：
aaabaaac
I  j   k
aaabaaaca
I  j   k
```

区间 `[i, j)` 是待拼接的区间
- 如果后续的 `a` 在 `(j, k)` 区间中，相当于拿到一个 `a` 补了上来。
- 如果后续的 `a` 不在 `(j, k)` 区间中，相当于拿到一个 `a` 将两个区间连接到了一起。

代码：
```Java
Public int maxRepOpt 1 (String text) {
	// 滑动窗口枚举的是所有的单字符串区间
	Char[] ct = text. ToCharArray ();
	Int n = ct. Length;
	Int[] rec = new int[26];
	Int ans = 0;
	For (int i = 0; i < n; i++) {
		Rec[ct[i] - 'a']++;
	}
	For (int i = 0; i < n;) {
		Int j = i;
		While (j < n && ct[j] == ct[i]) {
			J++;
		}
		Int len = j - i;
		If (len == rec[ct[i] - 'a']) {
			Ans = Math. Max (ans, len);
		} else { // 后续还有 a
			int k = j + 1;
			while (k < n && ct[k] == ct[i]) {
				k++;
			}
			If (k - j - 1 == rec[ct[i] - 'a'] - len) {
				ans = Math. Max (ans, k - j - 1 + len);
			} else {
				ans = Math. Max (ans, k - j + len);
			}
		}
		i = j;
	}
	return ans;
}
```


## LC 1208. 尽可能使字符串相等

代码：

```java
Public int equalSubstring (String s, String t, int maxCost) {
    char[] cs = s.toCharArray ();
    char[] ts = t.toCharArray ();
    Int n = cs. Length;
    Int[] rec = new int[n];
    For (int i = 0; i < n; i++) {
        Rec[i] = Math. Abs (cs[i] - ts[i]);
    }
    Int count = 0;
    Int ans = 0;
    For (int i = 0, j = 0; j < n; j++) {
        Count += rec[j];
        While (count > maxCost) {
            Count -= rec[i];
            I++;
        }
        Ans = Math. Max (ans, j - i + 1);
    }
    Return ans;
}
```

## LC 1234. 替换子串得到平衡字符串
描述：
```latex
有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。
假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。
给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。
你可以用和「待替换子串」长度相同的任何其他字符串来完成替换。
请返回待替换子串的最小可能长度。
如果原字符串自身就是一个平衡字符串，则返回 0。
```
思考：
```latex
QQWW need diff
Q: 2  1    1
W: 2  1    1
E: 0  1    -1
R: 0  1    -1
```
求至少有 1 个 Q 和 1 个 W 的滑动窗口的最小长度。
- 不满足这个条件，滑动窗口右扩。
- 满足这个条件，滑动窗口左缩，并更新滑动窗口的最小长度。

特殊条件：
滑动窗口的最小长度是 1（j - i + 1），特殊情况的 0 直接提前返回就可以了。

代码： 
```Java
Public int balancedString (String s) {
	char[] cs = s.toCharArray ();
	Int n = cs. Length;
	Int[] rec = new int[4];
	For (int i = 0; i < n; i++) {
		If (cs[i] == 'Q') rec[0]++;
		If (cs[i] == 'W') rec[1]++;
		If (cs[i] == 'E') rec[2]++;
		If (cs[i] == 'R') rec[3]++;
	}
	Int require = n / 4;
	Int[] counts = new int[4];
	// 特殊情况直接满足，返回 0
	For (int i = 0; i < 4; i++) {
		Counts[i] = rec[i] - require;
	}
	Boolean flag = false;
	For (int i = 0; i < 4; i++) {
		If (counts[i] != 0) {
			Flag = true;
			Break;
		}
	}
	If (! Flag) {
		Return 0;
	}
	Int[] map = new int[4];
	Int ans = n;
	For (int i = 0, j = 0; j < n; j++) {
		If (cs[j] == 'Q') map[0]++;
		If (cs[j] == 'W') map[1]++;
		If (cs[j] == 'E') map[2]++;
		If (cs[j] == 'R') map[3]++;
		While (i <= j && check (counts, map)) {
			// 滑动窗口长度至少是 1
			Ans = Math. Min (ans, j - i + 1);
			If (cs[i] == 'Q') map[0]--;
			If (cs[i] == 'W') map[1]--;
			If (cs[i] == 'E') map[2]--;
			If (cs[i] == 'R') map[3]--;
			I++;
		}
	}
	Return ans;
}

Private boolean check (int[] counts, int[] map) {
	// 对应的正数要大
	For (int i = 0; i < counts. Length; i++) {
		If (counts[i] > 0 && map[i] < counts[i]) {
			Return false;
		}
	}
	Return true;
}
```

## LC 1297 子串的最大出现次数
描述：
```latex
给你一个字符串 s ，请你返回满足以下条件且出现次数最大的任意子串的出现次数：
1. 子串中不同字母的数目必须小于等于 maxLetters 。
2. 子串的长度必须大于等于 minSize 且小于等于 maxSize 。
```

思考：
两个条件不要同时考虑，首先考虑第一个条件，得到不同字母的数目小于等于 `maxLetters` 的滑动窗口后再处理条件 2。

代码:
```Java
Public int maxFreq (String s, int maxLetters, int minSize, int maxSize) {
	int n = s.length ();
	HashMap<Character, Integer> map = new HashMap<>();
	HashMap<String, Integer> rec = new HashMap<>();
	Int ans = 0;
	For (int i = 0, j = 0; j < n; j++) {
		char c = s.charAt (j);
		Map. Put (c, map. GetOrDefault (c, 0) + 1);
		while (i <= j && map.size() > maxLetters) {
			char ch = s.charAt (i);
			Int count = map. Get (ch);
			If (count == 1) {
				Map. Remove (ch);
			} else {
				Map. Put (ch, count - 1);
			}
			I++;
		}
		// 以 j 为结尾的，最多含有 maxLetters 种字符的子串为 s[i: j]
		// 本题记录最短的就可以了
		Int k = j + 1 - minSize;
		If (i <= k) {
			String str = s.substring (k, j + 1);
			Int val = rec. GetOrDefault (str, 0) + 1;
			If (val > ans) {
				Ans = val;
			}
			Rec. Put (str, val);
		}
		// 考虑 maxSize 的话要考虑下标 k 的起始位置
		// int k = j + 1 - maxSize;
		// if (i > j + 1 - maxSize) {
		//     for (k = i; k <= j + 1 - minSize; k++) {
		//         String str = s.substring (k, j + 1);
		//         rec. Put (str, rec. GetOrDefault (str, 0) + 1);
		//     }
		// } else {
		//     for (; k <= j + 1 - minSize; k++) {
		//         String str = s.substring (k, j + 1);
		//         rec. Put (str, rec. GetOrDefault (str, 0) + 1);
		//     }
		// }
	}
	// int ans = 0;
	// for (Map. Entry<String, Integer> entry : rec. EntrySet ()) {
	//     ans = Math. Max (ans, entry. GetValue ());
	// }
	Return ans;
}
```

## LC 1358 包含所有三种字符的子字符串数目

描述：
```latex
给你一个字符串 s ，它只包含三种字符 a, b 和 c 。
请你返回 a，b 和 c 都至少出现过一次的子字符串数目。
```
思考：
`a, b, c` 至少出现了一次
- 不满足条件，滑动窗口右扩。
- 满足条件，滑动窗口左缩，并且处理结果。滑动窗口满足条件，滑动窗口作为前缀，后续拼接的字符串都满足条件。

处理结果：
```latex
Aabcabc

[aabc]
[aabc]a, [aabc]ab, [aabc]abc 都满足条件
A[abc]a, a[abc]ab, a[abc]abc
```

代码：
```Java
Public int numberOfSubstrings (String s) {
	char[] cs = s.toCharArray ();
	Int n = cs. Length;
	Int[] rec = new int[3];
	Int ans = 0;
	For (int i = 0, j = 0; j < n; j++) {
		Rec[cs[j] - 'a']++;
		While (i <= j && check (rec)) {
			Ans += n - 1 - j + 1;
			Rec[cs[i] - 'a']--;
			I++;
		}
	}
	Return ans;
}

Private boolean check (int[] rec) {
	For (int i = 0; i < rec. Length; i++) {
		If (rec[i] <= 0) {
			Return false;
		}
	}
	Return true;
}
```

## LC 1423. 可获得的最大点数

描述：
```latex
几张卡牌排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。
每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。
你的点数就是你拿到手中的所有卡牌的点数之和。
给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。
```

要点：
环形滑动窗口

代码：

```java
Public int maxScore (int[] cardPoints, int k) {
    Int n = cardPoints. Length;
    Int i = n - k;
    Int j = n - 1;
    Int sum = 0;
    For (int m = i; m <= j; m++) {
        Sum += cardPoints[m];
    }
    J++;
    // 后续只滑动 k 次
    Int ans = sum;
    For (int count = 1; count <= k; count++, j++) {
        Sum += cardPoints[j % n];
        Sum -= cardPoints[(j - k) % n];
        Ans = Math. Max (ans, sum);
    }
    Return ans;
}
```

## LC 1438.  绝对值不超过限制的最长连续子数组（单调队列）

描述：

滑动窗口的最大值 - 滑动窗口的最小值 <= limit，类比 [[#LC 239. 滑动窗口的最大值 (单调队列)]]。

代码：

```java
Public int longestSubarray (int[] nums, int limit) {
    Int n = nums. Length;
    Int ans = 0;
    LinkedList<Integer> maxQue = new LinkedList<>(), minQue = new LinkedList<>();
    For (int r = 0, l = 0; r < n; r++) {
        While (! MaxQue. IsEmpty () && maxQue. PeekLast () < nums[r]) {
            MaxQue. PollLast ();
        }
        While (! MinQue. IsEmpty () && minQue. PeekLast () > nums[r]) {
            MinQue. PollLast ();
        }
        MaxQue. OfferLast (nums[r]);
        MinQue. OfferLast (nums[r]);
        While (!MaxQue. IsEmpty () && 
               !MinQue. IsEmpty () &&
               Math. Abs (maxQue. PeekFirst () - minQue. PeekFirst ()) > limit) {
            If (maxQue. PeekFirst () == nums[l]) {
                MaxQue. PollFirst ();
            }
            If (minQue. PeekFirst () == nums[l]) {
                MinQue. PollFirst ();
            }
            L++;
        }
        Ans = Math. Max (ans, r - l + 1);
    }
    Return ans;
}
```



## LC 1610. 可见点的最大数目

排序+环形滑动窗口

```java
public int visiblePoints (List<List<Integer>> points, int angle, List<Integer> location) {
    Int posX = location. Get (0);
    Int posY = location. Get (1);
    List<Double> angles = new ArrayList<>();
    Int origin = 0;
    Double M = 180 / Math. PI;
    for (List<Integer> list : points) {
        Int x = list. Get (0);
        Int y = list. Get (1);
        Double diffX = (x - posX) * 1.0;
        Double diffY = (y - posY) * 1.0;
        // 使用角度制
        // 点是原点就是特殊情况
        Double tar = Math. Atan 2 (diffY, diffX) * M;
        If (diffX == 0.0 && diffY == 0.0) {
            Origin++;
            Continue;
        }
        Angles. Add (tar);
    }
    Int ans = 0;
    // 这里要排序
    // 这个点是自己的话什么角度都可以
    Collections. Sort (angles);
    // 把前面所有的数 + 360° 再添加一遍到后面，类似于环形滑动窗口
    // 这里的 angles. Size () 是变化的
    Int n = angles. Size ();
    For (int i = 0; i < n; i++) {
        Angles. Add (angles. Get (i) + 360.0);
    }
    For (int i = 0, j = 0; j < angles. Size (); j++) {
        While (angles. Get (j) - angles. Get (i) > angle) {
            I++;
        }
        Ans = Math. Max (ans, j - i + 1);
    }
    Return ans + origin;
}
```

## LC 1695. 删除子数组的最大得分

代码：
```Java
Public int maximumUniqueSubarray (int[] nums) {
	Int n = nums. Length;
	Int sum = 0;
	HashSet<Integer> set = new HashSet<>();
	Int ans = 0;
	For (int i = 0, j = 0; j < n; j++) {
		Sum += nums[j];
		While (i <= j && set. Contains (nums[j])) {
			Sum -= nums[i];
			Set. Remove (nums[i]);
			I++;
		}
		Set. Add (nums[j]);
		Ans = Math. Max (ans, sum);
	}
	Return ans;
}
```

## LC 1838.  最高频元素的频数

![](https://img2023.cnblogs.com/blog/3118374/202403/3118374-20240320124846702-694600636.svg)

要点：

统计的是 nums[i] - nums[j - 1] 的各个元素与 nums[j] 的差值和

代码：

```java
Public int maxFrequency (int[] nums, int k) {
    Arrays. Sort (nums);
    Int n = nums. Length;
    Int ans = 1;
    Int diffSum = 0;
    For (int i = 0, j = 1; j < n; j++) {
        DiffSum += (nums[j] - nums[j - 1]) * (j - i);
        While (diffSum > k) {
            DiffSum -= (nums[j] - nums[i]);
            I++;
        }
        Ans = Math. Max (ans, j - i + 1);
    }
    Return ans;
}
```



## LC 1984. 学生分数的最小差值

## LC 2024.  考试的最大困扰度
