# 线性动态规划

## 单串问题

### 经典的LIS问题

[LeetCode 第300题 最长递增子序列的长度](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

[LeetCode 第673题 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

[LeetCode 第354题 俄罗斯套娃信封](https://leetcode-cn.com/problems/russian-doll-envelopes/)

最大字串和系列

[LeetCode 第53题 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[LeetCode 第152题 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

[LeetCode 第918题 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

[LeetCode 面试题17.24 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)

[矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

[LeetCode 第1055题 形成字符串的最短路径](https://leetcode-cn.com/problems/shortest-way-to-form-string/)

### 单串问题 ：变形，需要两个位置dp[i]，dp[j]的情况

[LeetCode 第873题 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/)

# 单串问题：与其他算法配合

### 单串问题：其它单串 $\mathrm{dp}[i]$ 问题

[LeetCode 第32题 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)



# 区间动态规划

## 回文问题

### 最长回文子串
### LeetCode 第5、647题
$dp[i][j]$ 只能从 dp[i + 1] [j - 1] 转移而来 $\mathrm{dp}[i][j]$
前面的 dp[i + 1] [j - 1] 是回文串，$dp[i][j]$ 就是回文串
前面的 dp[i + 1] [j - 1] 不是回文串，dp[i] [j] 就不是回文串
所以 dp[i] [j]是 boolean 型的

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701091817196.png" alt="image-20220701091817196" style="zoom:50%;" /></center>

这里 j == i + 1 且字符相等时，不能直接从 $dp[i-1][j-1]$转移。

这就是区间回文的 sentinel，注意初始的状态转移。

### 最长回文子序列

回文子序列的逻辑可以统一起来

回文子序列的dp[i] [j]是长度，可以从3个方向转移而来

初始的状态转移0$$\rightarrow$$2可以统一逻辑

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701092847884.png" alt="image-20220701092847884" style="zoom:50%;" />

### 段式回文

```java
public int longestDecomposition(String text) {
	//这个函数本身就是一个dp数组
	int len = text.length();
	//奇数和偶数要考虑清楚
	for (int i = 1; i <= len / 2; i++) {
		if (text.substring(0, i).equals(text.substring(len - i, len))) {
			return 2 + longestDecomposition(text.substring(i, len - i));
		}
	}
	return len == 0 ? 0 : 1;
}
```

段式回文这个函数本身就是一个dp数组，实际上是用来==缩小问题规模==的

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701103643555.png" alt="image-20220701103643555" style="zoom:50%;" />

$$
5/2=2\\
4/2=2
$$
数组长度len

- len为奇数，len/2就是中间元素的索引
- len为偶数，len/2就是中间靠右的元素的索引

### LeetCode 第730题 统计不同的回文子序列

```java
public int countPalindromicSubsequences(String s) {
        final int MOD = 1000000007;
        char[] chars = s.toCharArray();
        int len = chars.length;
        //i、j之间不重复的回文子序列的个数
        int[][] dp = new int[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = 1;
        }

        for (int i = len - 1; i >= 0; i--) {
            for (int j = i + 1; j < len; j++) {
                if (chars[i] == chars[j]) {
                    int left = i + 1;
                    int right = j - 1;
                    while (left <= right && chars[left] != chars[i]) {
                        left++;
                    }
                    while (right >= left && chars[right] != chars[j]) {
                        right--;
                    }
                    //找到了2个
                    //最开始不用left != j 和 right != i的条件
                    if (left < right) {
                        dp[i][j] = ((2 * dp[i + 1][j - 1] % MOD)
                         - dp[left + 1][right - 1] + MOD) % MOD;
                    }

                    if (left == right) {
                        dp[i][j] = (2 * dp[i + 1][j - 1] + 1) % MOD;
                    }
                    //最开始的逻辑在这里
                    if (left > right) {
                        dp[i][j] = (2 * dp[i + 1][j - 1] + 2) % MOD;
                    }

                } else {
                    dp[i][j] = ((dp[i + 1][j] + dp[i][j - 1]) % MOD - dp[i + 1][j - 1] + MOD) % MOD;
                }
            }
        }
        return dp[0][len - 1];
    }
```

不同序列的叠加是如何去重的？

$$dp[i][j]$$ 的含义：$chars[i][j]$ 之间不含重复的回文子序列的个数

如果 $$chars[i]$$ 和 $chars[j]$ 是一样的字符，考虑 $chars[i+1]$ 和 $chars[j-1]$ 的关系

- $[i+1,\ j-1]$ 之间==没有==这个字符($chars[i]==chars[j]$)

$$
dp[i][j]=2*dp[i+1][j-1]+2
$$

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701161342453.png" alt="image-20220701161342453" style="zoom:50%;" />

相当于区间$[i-1,\ j+1]$的不重复的回文子序列规模$\times2$，然后加$2$(a, aa)<!---->

- $[i+1,\ j-1]$​之间==有一个==这个字符

$$
dp[i][j]=2*dp[i+1][j-1]+1
$$

![image-20220701162518072](https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701162518072.png)

区间 $[i-1,\ j+1]$ 的不重复的回文子序列规模 $\times2$，但是只能加上 $a$ 了。

- $[i+1,\ j-1]$​之间==有2个及以上==这个字符

$$
dp[i][j]=2*dp[i+1][j-1]-dp[low][high]
$$

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220701163726225.png" alt="image-20220701163726225" style="zoom: 33%;" />

区间$[i-1,\ j+1]$的不重复的回文子序列规模$\times2$，a 和 aa 都不能加了，而且$[low,\ high]$之间的无重复回文子序列算了两边，要减去一个。

这里的规模从小到大，前面的字符的情况都考虑过了。



如果$$chars[i]$$和$chars[j]$是不一样的字符
$$
dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]
$$
注意点


- 子程序：在一个字符串中求第一个和最后一个 a 出现的索引值

  ```java
  int left = i + 1;
  int right = j - 1;
  while(left <= right && chars[left] != chars[i]) {
  	left++;
  }
  while(right >= left && chars[right] != chars[j]) {
  	right--;
  }
  ```



### LeetCode 第576题 移除盒子（消消乐）

错误思路：$\mathrm{dp}[i][j]$ 表示移除区间 $[i,\ j]$ 所有盒子所获得的最大积分，积分除了与区间$[i,\  j]$有关，还与后面的数字有关

$dp[i][j][k]$表示区间$[i,\ j]$加上后续的$k$个与$array[j]$相同的字符的最大得分。

区间动态规划，采用分治的思想，这里区间$[i,\ j]$遍历的时候需要知道==区间中任意一段的值==。

<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220702131659976.png" alt="image-20220702131659976" style="zoom:50%;" />

状态转移方程：这里 $\mathrm{array}[t]=\mathrm{array}[j]$，这样前面和后面相同的数就都考虑进去了。
$$
\mathrm{dp}[i][j][k]=\mathrm{max}\bigg\{dp[i][j-1][0]+(k+1)^2+\max\limits^{j-1}\limits_{t=i}\big\{dp[t+1][j-1][0]+dp[i][t][k+1]\big\}\bigg\}
$$
<img src="https://gaorq.oss-cn-shanghai.aliyuncs.com/imgs/imgs1/image-20220702134946082.png" alt="image-20220702134946082" style="zoom:50%;" />

==这里的k每次循环都可以统计出来==。

完整代码

```java
class Solution {
    public int removeBoxes(int[] boxes) {
        int len = boxes.length;
        int[][][] dp = new int[len + 1][len + 1][len + 1];
        for (int i = 0; i < len; i++) {
            dp[i][i][0] = 1;
        }
        //这里为什么是从前向后遍历？
        //这里是按照长度从小到大遍历的
        for (int n = 1; n <= len; n++) {
            for (int i = 0; i + n - 1 < len; i++) {
                int j = i + n - 1;
        		//这里的k并不是真正的k,而是一种记录
                int kNum = 0;
                for (int p = j + 1; p < len; p++) {
                    if (boxes[p] == boxes[j]) {
                        kNum++;
                    }
                }
                for (int k = 0; k <= kNum; k++) {
                    dp[i][j][k] = Math.max(dp[i][j][k], (i == j ?
                    0 : dp[i][j - 1][0]) + (k + 1) * (k + 1));
                    for (int t = i; t <= j - 1; t++) {
                        if (boxes[t] == boxes[j]) {
                            //这里i从t + 1处传过来
                            dp[i][j][k] = Math.max(dp[i][j][k],
                            (t + 1 <= j - 1 ? dp[t + 1][j - 1][0] : 0) 
                            + dp[i][t][k + 1]);
                        }
                    }
                }
            }
        }
        return dp[0][len - 1][0];
    }
}
```

